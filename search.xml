<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1765 谷歌的恐龙</title>
    <url>/2020/02/20/1765%20%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%81%90%E9%BE%99/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>把整个游戏简化为，每次生成一个[0,n)的随机数，如果这个随机数和给出的m个数字中的其中一个数字相等，那么就停止生成随机数，否则继续生成，求出所有生成的数的和的期望。</p>
<h2 id="solution">Solution</h2>
<p><span class="math display">\[ E = \sum_{i=0}^{n-1} p_i \times(i+[flag_i]\times E), p_i = \frac{1}{n}, 如果i不在m个数中, flag_i = 1, 否则为0。 \]</span></p>
<p>化简为<span class="math display">\[ E = \frac{n\times(n-1)}{2\times m} \]</span> ## Code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod=998244353;</span><br><span class="line">int mo(ll a,int p)&#123;</span><br><span class="line">    return a&gt;=p?a%p:a;</span><br><span class="line">&#125;</span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,x;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%.6f\n&quot;,n*(n-1)/2.0/m);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>2504 是子序列的个数</title>
    <url>/2020/02/20/2504%20%E6%98%AF%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小b有一个字符串S和n个字符串words[1...n]，现在她想知道有多少个i满足words[i]是S的子序列。</p>
<p>S的长度≤50000，1≤n≤5000，words[i]长度≤50.</p>
<p>样例解释</p>
<p>a，acd，ace都是abcde的子序列，但bb不是。</p>
<h2 id="solution">Solution</h2>
<p>存一下s各个字母的位置，比较时二分查找。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod=998244353;</span><br><span class="line">int mo(ll a,int p)&#123;</span><br><span class="line">    return a&gt;=p?a%p:a;</span><br><span class="line">&#125;</span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line">int ans,n;</span><br><span class="line">string s,x;</span><br><span class="line">int a[27][500020];</span><br><span class="line">bool fun(string &amp;cur)&#123;</span><br><span class="line">    //cout&lt;&lt;cur&lt;&lt;&quot;:\n&quot;;</span><br><span class="line">    int las=0,l,r,mid,anss;</span><br><span class="line">    for(char i : cur)&#123;</span><br><span class="line">        l=1,r=a[i-&#x27;a&#x27;][0],anss=0;</span><br><span class="line">        while(l&lt;=r)&#123;</span><br><span class="line">            mid=l+r&gt;&gt;1;</span><br><span class="line">            if(a[i-&#x27;a&#x27;][mid]&gt;las)&#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">                anss=mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!anss)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        las=a[i-&#x27;a&#x27;][anss];//cout&lt;&lt;las&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">        a[s[i]-&#x27;a&#x27;][++a[s[i]-&#x27;a&#x27;][0]]=i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        if(fun(x))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>51Nod 2656 阿克曼函数</title>
    <url>/2019/09/08/51Nod%202656%20%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>阿克曼（Arkmann）函数 𝐴(𝑚,𝑛) 中，m与n的定义域是非负整数且本题中m&lt;=3，n&lt;=16。</p>
<p>函数的定义为：</p>
<figure>
<img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=d8f830180fb30f242197e451a9fcba26/d8f9d72a6059252d775b867d349b033b5bb5b97f.jpg" alt="阿克曼函数" /><figcaption>阿克曼函数</figcaption>
</figure>
<h2 id="solution">Solution</h2>
<p>可以推出代码中的结论。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">ll akm(int m,int n)&#123;</span><br><span class="line">    if(m==4&amp;&amp;n==0) return 13;</span><br><span class="line">    if(m==0) return n+1;</span><br><span class="line">    else if(m==1) return n+2;</span><br><span class="line">    else if(m==2) return 2*n+3;</span><br><span class="line">    else if(m==3) return ((1LL&lt;&lt;(n+3))-3);</span><br><span class="line">    else if(m==4)&#123;</span><br><span class="line">        return (1LL&lt;&lt;(akm(m,n-1)+3))-3;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;ERROR!&quot;&lt;&lt;endl;</span><br><span class="line">    while(1);</span><br><span class="line">&#125;</span><br><span class="line">int m,n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;akm(m,n)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1021 石子归并</title>
    <url>/2019/09/02/51Nod1021%20%E7%9F%B3%E5%AD%90%E5%BD%92%E5%B9%B6/</url>
    <content><![CDATA[<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[120],sum[120];</span><br><span class="line">int dp[120][120];</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[i][j]=10000000;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i-1]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int len=2;len&lt;=n;len++)&#123;</span><br><span class="line">        for(int i=1;i+len-1&lt;=n;i++)&#123;</span><br><span class="line">            int j=i+len-1;</span><br><span class="line">            for(int k=i;k&lt;=j;k++)&#123;</span><br><span class="line">                dp[i][j]=min(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1],dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[1][n]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1006最长公共子序列Lcs</title>
    <url>/2019/02/22/51Nod1006%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97Lcs/</url>
    <content><![CDATA[<p>给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。</p>
<p>比如两个串为：</p>
<p>abcicba</p>
<p>abdkscab</p>
<p>ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。</p>
<h1 id="输入">输入</h1>
<pre><code>第1行：字符串A
第2行：字符串B
(A,B的长度 &lt;= 1000)</code></pre>
<h1 id="输出">输出</h1>
<pre><code>输出最长的子序列，如果有多个，随意输出1个。</code></pre>
<h1 id="输入样例">输入样例</h1>
<pre><code>abcicba
abdkscab</code></pre>
<h1 id="输出样例">输出样例</h1>
<pre><code>abca  
  



 1 #include&lt;cstdio&gt;
 2 #include&lt;iostream&gt;
 3 #include&lt;cstring&gt;
 4 #include&lt;algorithm&gt;
 5 using namespace std;
 6 char a[1020],b[1020];
 7 int f[1020][1020];
 8 int ans[1020][1020];
 9 void dfs(int x,int y)&#123;
10     if(x==0||y==0) return;
11     if(ans[x][y]==0)&#123;
12         dfs(x-1,y-1);
13         cout&lt;&lt;b[y];
14     &#125;
15     else if(ans[x][y]==1)&#123;
16         dfs(x-1,y);
17     &#125;
18     else&#123;
19         dfs(x,y-1);
20     &#125;
21 &#125;
22 int main()&#123;
23     cin&gt;&gt;a&gt;&gt;b;
24     int l1=strlen(a),l2=strlen(b);
25     for(int i=l1;i&gt;=1;i--) a[i]=a[i-1];
26     for(int i=l2;i&gt;=1;i--) b[i]=b[i-1];
27     for(int i=1;i&lt;=l1;i++)&#123;
28         for(int j=1;j&lt;=l2;j++)&#123;
29             if(a[i]==b[j])&#123;
30                 f[i][j]=f[i-1][j-1]+1;
31                 ans[i][j]=0;
32             &#125;
33             else if(f[i-1][j]&gt;=f[i][j-1])&#123;
34                 f[i][j]=f[i-1][j];
35                 ans[i][j]=1;
36             &#125;
37             else&#123;
38                 f[i][j]=f[i][j-1];
39                 ans[i][j]=-1;
40             &#125;
41         &#125;
42     &#125;
43     //cout&lt;&lt;f[l1][l2];
44     dfs(l1,l2);
45     return 0;
46 &#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>51Nod1051 最大子矩阵和</title>
    <url>/2019/10/23/51Nod1051%20%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>一个M*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。</p>
<p>例如：3*3的矩阵：</p>
<p>-1 3 -1</p>
<p>2 -1 3</p>
<p>-3 1 2</p>
<p>和最大的子矩阵是：</p>
<p>3 -1</p>
<p>-1 3</p>
<p>1 2</p>
<h2 id="solution">Solution</h2>
<p>枚举上下边界，竖着加起来，横向算最大字段和。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">//#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">ll a[520][520];</span><br><span class="line">ll f[520];</span><br><span class="line">ll sum[520][520];</span><br><span class="line">ll mx=0;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;a[i][j]);</span><br><span class="line">            sum[i][j]=sum[i-1][j]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            for(int k=1;k&lt;=m;k++)&#123;</span><br><span class="line">                f[k]=max(0LL,f[k-1]+sum[j][k]-sum[i-1][k]);</span><br><span class="line">                mx=max(mx,f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,mx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1050 循环数组最大子段和</title>
    <url>/2019/10/23/51Nod1050%20%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。 例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。</p>
<h2 id="solution">Solution</h2>
<p>最大字段和最大，或者去掉中间某个最小字段和剩下的最大。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">ll a[50020];</span><br><span class="line">ll fmn[50020],fmx[50020],mn=0,mx=0,sum;</span><br><span class="line">int main() &#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        fmx[i]=max(a[i],fmx[i-1]+a[i]);</span><br><span class="line">        mx=max(mx,fmx[i]);</span><br><span class="line">        fmn[i]=min(a[i],fmn[i-1]+a[i]);</span><br><span class="line">        mn=min(mn,fmn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max(mx,sum-mn);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1029 大数除法</title>
    <url>/2019/10/19/51Nod1029%20%E5%A4%A7%E6%95%B0%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给出2个大整数A,B，计算A / B和A Mod B的结果。</p>
<h2 id="solution">Solution</h2>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=int(input())</span><br><span class="line">b=int(input())</span><br><span class="line">c=a//b</span><br><span class="line">print(c)</span><br><span class="line">print(a-c*b)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1067 Bash游戏 V2</title>
    <url>/2019/07/23/51Nod1067%20Bash%E6%B8%B8%E6%88%8F%20V2/</url>
    <content><![CDATA[<p>##题意 有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。</p>
<p>##思路 博弈论，从零开始推状态，方法详见<a href="https://www.cnblogs.com/sz-wcc/p/11071914.html">欧几里得游戏(博弈论启蒙)</a>。 最后发现%7为0和2的数是必败态，其它是必胜态。</p>
<p>##代码 #include<iostream> #include<cstdio> #include<cstdio> #include<algorithm> #define ll long long using namespace std; ll T,n; int main(){ cin&gt;&gt;T; while(T--){ cin&gt;&gt;n; if(n%7==2||n%7==0){ cout&lt;&lt;&quot;B&quot;; } else{ cout&lt;&lt;&quot;A&quot;; } }</p>
<pre><code>    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>51Nod1065 最小正子段和</title>
    <url>/2019/10/04/51Nod1065%20%E6%9C%80%E5%B0%8F%E6%AD%A3%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>N个整数组成的序列a[1],a[2],a[3],…,a[n]，从中选出一个子段（a[i],a[i+1],…a[j]），使这个子段的和&gt;0，并且这个和是所有和&gt;0的子序列中最小的。</p>
<p>例如：4，-1，5，-2，-1，2，6，-2。-1，5，-2，-1，序列和为1，是最小的。</p>
<h2 id="solution">Solution</h2>
<p>求前缀和，用map存每个数出现的最小最大坐标，去重，相邻两个能组成的话，差取最小，注意加入0。</p>
<blockquote>
<p>解释一下为什么只需检查相邻2个数就可以，设ABC是排序后的结果，如果A同B不能组成序列，而A同C可以组成序列，那么B同C也可以组成序列，并且BC会是一个更优的解。</p>
</blockquote>
<p>%一下远古巨佬</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mod 998244353LL</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">ll lowspeed(ll a,ll b,ll p)&#123;ll cur=a,ans=0;while(b)&#123;if(b&amp;1) ans=(ans+cur)%p;cur=(cur+cur)%p;b&gt;&gt;=1;&#125;return ans%p;&#125;</span><br><span class="line">ll speed(ll a,ll b,ll p)&#123;ll cur=a,ans=1;while(b)&#123;if(b&amp;1) ans=lowspeed(ans,cur,p)%p;cur=lowspeed(cur,cur,p)%p;b&gt;&gt;=1;&#125;return ans%p;&#125;</span><br><span class="line">int n;</span><br><span class="line">ll a[50020];</span><br><span class="line">ll ans=1e15;</span><br><span class="line">map&lt;int,int&gt;mx;</span><br><span class="line">map&lt;int,int&gt;mn;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i]+=a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!mn[a[i]])&#123;</span><br><span class="line">            mn[a[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        mx[a[i]]=i;</span><br><span class="line">    &#125;sort(a,a+1+n);</span><br><span class="line">    ll m=unique(a,a+1+n)-(a+1);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        if(mn[a[i]]&lt;mx[a[i+1]])&#123;</span><br><span class="line">            ans=min(ans,a[i+1]-a[i]);</span><br><span class="line">            //cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;&lt;&lt;a[i+1]&lt;&lt;endl;</span><br><span class="line">            //cout&lt;&lt;mn[a[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;mx[a[i+1]]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if(ans==1e15)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1070 Bash游戏 V4</title>
    <url>/2019/09/02/51Nod1070%20Bash%E6%B8%B8%E6%88%8F%20V4/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量最少1个，最多不超过对手上一次拿的数量的2倍（A第1次拿时要求不能全拿走）。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。</p>
<p>例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。 ## Solution 打表写了半天，等我看明白怎么证回来补。 ## Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">int T,n;</span><br><span class="line">bool fg;</span><br><span class="line">int dfs(int cur,int cnt)&#123;</span><br><span class="line">    if(cur==0) return 0;</span><br><span class="line">    if(cur==1) return 1;</span><br><span class="line">    if(cur==2) return 1;</span><br><span class="line">    bool fg2=fg;</span><br><span class="line">    fg=false;</span><br><span class="line">    for(int i=1;i&lt;=min(2*cnt,cur);i++)&#123;</span><br><span class="line"></span><br><span class="line">        if(fg2&amp;&amp;i==cur) break;//cout&lt;&lt;&quot;*&quot;&lt;&lt;i&lt;&lt;&quot;*&quot;&lt;&lt;endl;</span><br><span class="line">        if(!dfs(cur - i, i)) return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">ll s[120]=&#123;0,1,1,2,3&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    /*for(int i=1;i&lt;=100;i++)&#123;</span><br><span class="line">        //if(i==3)cout&lt;&lt;&quot;!!!&quot;&lt;&lt;endl;</span><br><span class="line">        fg=true;</span><br><span class="line">        if(i!=2) cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dfs(i,9999)&lt;&lt;endl;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout&lt;&lt;&quot;2:0\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(i==3) cout&lt;&lt;&quot;!!!&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;*/</span><br><span class="line">    for(int i=5;i&lt;=100&amp;&amp;s[i-1]&lt;10000000000;i++)&#123;</span><br><span class="line">        s[i]=s[i-1]+s[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        bool k=false;</span><br><span class="line">        for(int i=2;i&lt;=100;i++)&#123;</span><br><span class="line">            if(s[i]==n)&#123;</span><br><span class="line">                k=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;B\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout&lt;&lt;&quot;A\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>51Nod1073 约瑟夫环</title>
    <url>/2019/07/23/51Nod1073%20%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    <content><![CDATA[<p>##题意 编号1~N，每数K个出局，范围1e6</p>
<p>##代码 #include<iostream> #include<cstdio> #include<cstdio> #include<algorithm> #define ll long long using namespace std; ll n,k; ll cur; int main(){ cin&gt;&gt;n&gt;&gt;k; cur=0; for(int i=2;i&lt;=n;i++){ cur=(cur+k)%i; } cur++; cout&lt;&lt;cur&lt;&lt;endl; return 0; }</p>
]]></content>
  </entry>
  <entry>
    <title>51Nod1072 威佐夫游戏</title>
    <url>/2019/07/23/51Nod1072%20%E5%A8%81%E4%BD%90%E5%A4%AB%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>##题意 有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。</p>
<p>##思路 枚举小数字的a,b，发现必败态有如下规律：</p>
<ul>
<li>每组必败态两数之差为1，2，3...</li>
<li>必败态任意数字不重复</li>
</ul>
<p>于是可以递推(1,2),(3,5)(4,7),(6,10)...</p>
<p>暴力可做，另有公式较小数a==(b-a)*1.618时为必败态。</p>
<p>1.618具体为(sqrt(5)+1)/2，V2必须用这个公式和高精，未做，日后再做。</p>
<p>##代码</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define ll long long
using namespace std;
ll T,a,b;
int c[5000020];
bool f[50000200];
ll abs(ll x)&#123;
    return x&gt;0?x:-x;
&#125;
void fun()&#123;
    memset(f,false,sizeof(f));
    int cnt=1;
    for(int i=1;i&lt;=5000000;i++)&#123;
        if(!f[i]&amp;&amp;!f[i+cnt])&#123;
            c[i]=i+cnt;
            f[i]=f[i+cnt]=true;
            cnt++;
        &#125;
    &#125;
&#125;
int main()&#123;
    fun();
    cin&gt;&gt;T;
    while(T--)&#123;
        cin&gt;&gt;a&gt;&gt;b;
        if(b&lt;a) swap(a,b);
        if(c[a]==b) cout&lt;&lt;&quot;B\n&quot;;
        else cout&lt;&lt;&quot;A\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>51Nod1068 Bash游戏 V3</title>
    <url>/2019/09/02/51Nod1068%20Bash%E6%B8%B8%E6%88%8F%20V3/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量只能是2的正整数次幂，比如(1,2,4,8,16....)，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。 例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。（输入的N可能为大数） ## Solution 打表发现3的倍数时为必败点，B赢。如果不是3的倍数可以-1或-2转移到3的倍数，必胜，考虑有没有可能后面出现一个3的倍数可以通过减2的幂转移到前面必败点，即3的更小倍数，化为表达式(3x-2^t)%3==0，很明显不能，那3的倍数就是必败点，其他是必胜点。 ## Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">int T;</span><br><span class="line">string s;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        ll cur=0;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">            cur*=10;</span><br><span class="line">            cur+=s[i]-&#x27;0&#x27;;</span><br><span class="line">            cur%=3;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur==0)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;B&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout&lt;&lt;&quot;A&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>51Nod1074 约瑟夫环 V2</title>
    <url>/2019/07/23/51Nod1074%20%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%20V2/</url>
    <content><![CDATA[<p>##题意 约瑟夫环，N-1e18，K-1000</p>
<p>##思路 由于K远小于N，后面i大了之后某些时候不用取模，可以加速。</p>
<p>##代码 #include<iostream> #include<cstdio> #include<cstdio> #include<algorithm> #define ll long long using namespace std; ll n,k; ll cur,t; int main(){ cin&gt;&gt;n&gt;&gt;k; cur=0; for(ll i=2;i&lt;=n;i+=t+1){ t=(i-cur)/k-1; if(t&lt;0) t=0; if(i+t+1&gt;n) t=n-i; cur=(cur+(t+1)*k)%(i+t); } cur++; cout&lt;&lt;cur&lt;&lt;endl; return 0; }</p>
]]></content>
  </entry>
  <entry>
    <title>51Nod1089最长回文子串 V2（Manacher算法）</title>
    <url>/2019/02/27/51Nod1089%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%20V2%EF%BC%88Manacher%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<p>俗称马拉车算法-&gt;_-&gt;</p>
<p>处理最长回文字串复杂度O(n)</p>
<p>这里菜鸡不会证，简单说一下思路。</p>
<p>由于回文串有奇有偶，所以将串之间和两边加上'#'，为了防止后面某个地方超边界，新串0位置加上$。这样每个回文子串为#a#b#a#形式，必定奇数个，且原子串长度为新字串半径减一，求这个半径p[i]。（即p[i]是以i为中心的最长回文字串的半径）</p>
<p>i从1到n，过程中维护一个id点(id&lt;i，i拉着id走，马拉车)，它是某个回文子串的中心，这个字串右边界是当前最大的。（p[i]是半径，故i+p[i]为边界）</p>
<p>那么当右边界比i还大时，就可以根据对称性，找到i关于id的对称点j=2*id-i，来优化找字串的过程。怎么优化呢？在id管辖范围内，p[i]和p[j]情况是相同的。由于超出id右边界的的地方不符合对称性，因此p[i]=p[j]当且仅当p[j]小于等于j-(id-p[id])（即j串的左边界不超出id串的左边界），否则只能直接到id右边界，p[i]=mx-i，之后的手动算。</p>
<p>如果id右边界太小，不能做优化，也得手动算。</p>
<p>以下代码：</p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;cstring&gt;
 4 #include&lt;string&gt;
 5 #define ll long long
 6 using namespace std;
 7 char s[100020],sn[200020];
 8 int p[200020];
 9 int init()&#123;
10     int len=strlen(s);
11     sn[0]=&#39;$&#39;;sn[1]=&#39;#&#39;;
12     int j=2;
13     for(int i=0;i&lt;len;i++)&#123;
14         sn[j++]=s[i];
15         sn[j++]=&#39;#&#39;;
16     &#125;
17     sn[j]=&#39;\0&#39;;
18     return j;
19 &#125;
20 int Manacher()&#123;
21     int len=init();
22     int mx_len=-1,id,mx=0;
23     for(int i=1;i&lt;len;i++)&#123;
24         if(i&lt;mx)&#123;
25             p[i]=min(p[2*id-i],mx-i);
26         &#125;
27         else&#123;
28             p[i]=1;
29         &#125;
30         while(sn[i-p[i]]==sn[i+p[i]]) p[i]++;
31         if(p[i]+i&gt;mx)&#123;
32             id=i;
33             mx=p[i]+i;
34         &#125;
35         mx_len=max(mx_len,p[i]-1);
36     &#125;
37     return mx_len;
38 &#125;
39 int main()&#123;
40     cin&gt;&gt;s;
41     cout&lt;&lt;Manacher();
42     return 0;
43 &#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>51Nod1095 Anigram单词</title>
    <url>/2019/07/24/51Nod1095%20Anigram%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>##题目 一个单词a如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的Anigram，例如单词army和mary互为Anigram。另：相同的2个单词不算Anigram。现在给定一个字典，输入Q个单词，从给出的字典中找出这些单词的Anigram。</p>
<p>##思路 一个map保存原串出现次数，一个map保存排序串出现次数，减一下</p>
<p>##代码 #include&lt;bits/stdc++.h&gt; #define ll long long #define db double using namespace std; int n,q; char s[20],sp[20]; map&lt;string,int&gt;mp1; map&lt;string,int&gt;mp2; int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s; strcpy(sp,s); sort(sp,sp+strlen(sp)); mp1[s]++;//cout&lt;&lt;s&lt;&lt;';'&lt;&lt;mp[s]&lt;&lt;endl; mp2[sp]++; } cin&gt;&gt;q; for(int i=1;i&lt;=q;i++){ cin&gt;&gt;s; strcpy(sp,s); sort(sp,sp+strlen(sp)); //cout&lt;&lt;sp&lt;&lt;':'&lt;&lt;mp[sp]&lt;&lt;' '&lt;&lt;s&lt;&lt;':'&lt;&lt;mp[s]&lt;&lt;' '; cout&lt;&lt;mp2[sp]-mp1[s]&lt;&lt;endl; } return 0; }</p>
]]></content>
  </entry>
  <entry>
    <title>51Nod1094 和为k的连续区间</title>
    <url>/2019/07/24/51Nod1094%20%E5%92%8C%E4%B8%BAk%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>##题目 一整数数列a1, a2, ... , an（有正有负），以及另一个整数k，求一个区间[i, j]，(1 &lt;= i &lt;= j &lt;= n)，使得a[i] + ... + a[j] = k。</p>
<p>##思路 前缀和+n方查找，1e8如果数据小也是可以过的，毕竟1级题，也可以求前缀和，对前缀和排序，枚举i位置，二分查找j位置。</p>
<p>##代码 #include&lt;bits/stdc++.h&gt; #define ll long long #define db double using namespace std; ll a[10020],sum[10020]; ll n,k; int main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); sum[i]=sum[i-1]+a[i]; } for(int i=1;i&lt;=n;i++){ for(int j=i;j&lt;=n;j++){ if(sum[j]-sum[i-1]==k){ printf(&quot;%d %d&quot;,i,j); return 0; } } } cout&lt;&lt;&quot;No Solution&quot;; return 0; }</p>
]]></content>
  </entry>
  <entry>
    <title>51Nod1097 拼成最小的数</title>
    <url>/2019/10/19/51Nod1097%20%E6%8B%BC%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>设有n个正整数，将它们联接成一排，组成一个最小的多位整数。</p>
<p>例如： n=2时，2个整数32，321连接成的最小整数为：32132， n=4时，4个整数55，31，312, 33 联接成的最小整数为：312313355</p>
<h2 id="solution">Solution</h2>
<p>最优的情况字符串a+b&lt;b+a，排序即可。</p>
<p>设置num(x)为字符串x代表的数字，num(a)<em>10^|b|+num(b) &lt; num(b)</em>10^|a|+num(a) -&gt; num(a)/(10^|a|-1) &lt; num(b)/(10^|b|-1)，排序即可。</p>
<h2 id="code1">Code1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">string s[10020];</span><br><span class="line">int n;</span><br><span class="line">int cmp(string x,string y)&#123;</span><br><span class="line">	return x+y&lt;y+x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	io_opt;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(s+1,s+1+n,cmp);</span><br><span class="line">	string ans=&quot;&quot;;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		ans+=s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">		if(i!=0&amp;&amp;i%1000==0) cout&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;ans[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code2">Code2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long double ld;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">struct E&#123;</span><br><span class="line">	int x,len;</span><br><span class="line">&#125;e[10020];</span><br><span class="line">int n;</span><br><span class="line">int t[20]=&#123;1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000&#125;;</span><br><span class="line">int cmp(E x,E y)&#123;</span><br><span class="line">	return (ld)x.x/(t[x.len]-1)&lt;(ld)y.x/(t[y.len]-1);</span><br><span class="line">&#125;</span><br><span class="line">int cur=0,tmp[20];</span><br><span class="line">int main()&#123;</span><br><span class="line">	io_opt;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;e[i].x;</span><br><span class="line">		e[i].len=0;</span><br><span class="line">		int xx=e[i].x;</span><br><span class="line">		while(xx)&#123;</span><br><span class="line">			e[i].len++;</span><br><span class="line">			xx/=10;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(e+1,e+1+n,cmp);</span><br><span class="line">	int cnt=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cur=0;</span><br><span class="line">		while(e[i].x)&#123;</span><br><span class="line">			tmp[++cur]=e[i].x%10;</span><br><span class="line">			e[i].x/=10;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=cur;j&gt;=1;j--)&#123;</span><br><span class="line">			cout&lt;&lt;tmp[j];</span><br><span class="line">			cnt++;</span><br><span class="line">			if(cnt%1000==0)&#123;</span><br><span class="line">				cout&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1103 N的倍数</title>
    <url>/2019/10/19/51Nod1103%20N%E7%9A%84%E5%80%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>一个长度为N的数组A，从A中选出若干个数，使得这些数的和是N的倍数。</p>
<p>例如：N = 8，数组A包括：2 5 6 3 18 7 11 19，可以选2 6，因为2 + 6 = 8，是8的倍数。</p>
<h2 id="solution">Solution</h2>
<p>前缀和取模，相同的都行，注意下标0。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">ll a[50020];</span><br><span class="line">vector&lt;int&gt; v[50020];</span><br><span class="line">int num[50020];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        num[i]=a[i];</span><br><span class="line">        a[i] += a[i - 1];</span><br><span class="line">        a[i] %= n;</span><br><span class="line">        //cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">     //cout&lt;&lt;endl;</span><br><span class="line">    for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">        if (v[a[i]].empty()) &#123;</span><br><span class="line">            v[a[i]].push_back(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            int l = v[a[i]][0], r = i;</span><br><span class="line">            //cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">            cout&lt;&lt;r-l&lt;&lt;endl;</span><br><span class="line">            for (int j = l+1; j &lt;= r; j++) &#123;</span><br><span class="line">                cout &lt;&lt; num[j] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1105 第K大的数</title>
    <url>/2019/10/21/51Nod1105%20%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>数组A和数组B，里面都有n个整数。</p>
<p>数组C共有n^2个整数，分别是：</p>
<p>A[0] * B[0],A[0] * B[1] ...... A[0] * B[n-1]</p>
<p>A[1] * B[0],A[1] * B[1] ...... A[1] * B[n-1]</p>
<p>......</p>
<p>A[n - 1] * B[0],A[n - 1] * B[1] ...... A[n - 1] * B[n - 1]</p>
<p>是数组A同数组B的组合,求数组C中第K大的数。</p>
<p>例如：</p>
<p>A：1 2 3，B：2 3 4。</p>
<p>A与B组合成的C为</p>
<pre><code>     A[0]  A[1]  A[2]</code></pre>
<p>B[0] 2 3 4</p>
<p>B[1] 4 6 8</p>
<p>B[2] 6 9 12</p>
<p>共9个数。</p>
<h2 id="solution">Solution</h2>
<p>一种二分套二分，二分答案，check的时候对每个数二分找更小的，有一些细节需要处理。</p>
<p>仔细考虑发现，找比二分的数小的数，只要扫一遍，另一个指针随时减。省掉一个log</p>
<h2 id="code1">Code1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=50020;</span><br><span class="line">ll n,k,a[MAXN],b[MAXN];</span><br><span class="line">ll cont(int cur,ll num)&#123;</span><br><span class="line">    ll t=a[cur],ans=0;</span><br><span class="line">    int l=1,r=n,mid;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)/2;</span><br><span class="line">        if(t*b[mid]&lt;=num)&#123;</span><br><span class="line">            l=mid+1;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            r=mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">bool check(ll x)&#123;</span><br><span class="line">    ll ans=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=cont(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    k=n*n-k+1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+1+n);</span><br><span class="line">    sort(b+1,b+1+n);</span><br><span class="line">    ll l=a[1]*b[1],r=a[n]*b[n],mid,ans;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)/2;</span><br><span class="line">        if(check(mid))&#123;</span><br><span class="line">            r=mid-1;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            l=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code2">Code2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">const int MAXN=50020;</span><br><span class="line">ll n,k,a[MAXN],b[MAXN];</span><br><span class="line">inline ll cont(int cur,ll num)&#123;</span><br><span class="line">    ll t=a[cur],ans=0;</span><br><span class="line">    int l=1,r=n,mid;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)/2;</span><br><span class="line">        if(t*b[mid]&lt;=num)&#123;</span><br><span class="line">            l=mid+1;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            r=mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">inline bool check(ll x)&#123;</span><br><span class="line">    ll ans=0;</span><br><span class="line">    int j=n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        while(a[i]*b[j]&gt;x) j--;</span><br><span class="line">        ans+=j;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //io_opt;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">    k=n*n-k+1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;a[i],&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(a+1,a+1+n);</span><br><span class="line">    std::sort(b+1,b+1+n);</span><br><span class="line">    ll l=a[1]*b[1],r=a[n]*b[n],mid,ans=r;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)/2;</span><br><span class="line">        if(check(mid))&#123;</span><br><span class="line">            r=mid-1;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            l=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1110 距离之和最小 V3</title>
    <url>/2019/10/12/51Nod1110%20%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C%E6%9C%80%E5%B0%8F%20V3/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>X轴上有N个点，每个点除了包括一个位置数据X[i]，还包括一个权值W[i]。点P到点P[i]的带权距离 = 实际距离 * P[i]的权值。求X轴上一点使它到这N个点的带权距离之和最小，输出这个最小的带权距离之和。</p>
<h2 id="solution">Solution</h2>
<p>中位数最小，加权可以看成多个点。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define fo(d,s,t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define fo0(d,s,t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef __int128 lll;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">ll n,cnt1,cnt2,ansx,ans;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int x,w;</span><br><span class="line">&#125;e[10020];</span><br><span class="line">int cmp(E x,E y)&#123;</span><br><span class="line">    return x.x&lt;y.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    fo(i,1,n)&#123;</span><br><span class="line">        cin&gt;&gt;e[i].x&gt;&gt;e[i].w;</span><br><span class="line">        cnt1+=e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e+1,e+1+n,cmp);</span><br><span class="line">    cnt1=cnt1/2+1;</span><br><span class="line">    fo(i,1,n)&#123;</span><br><span class="line">        cnt2+=e[i].w;</span><br><span class="line">        if(cnt2&gt;=cnt1)&#123;</span><br><span class="line">            ansx=e[i].x;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fo(i,1,n)&#123;</span><br><span class="line">        ans+=abs(ansx-e[i].x)*e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1120 机器人走方格 V3</title>
    <url>/2019/07/29/51Nod1120%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E6%96%B9%E6%A0%BC%20V3/</url>
    <content><![CDATA[<p>##题目</p>
<p>N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。 N&lt;=1e9</p>
<p>##思路</p>
<p>卡特兰数+卢卡斯定理+乘法逆元算组合数</p>
<p>卡特兰数：某百科卡特兰数词条讲过这种情况。</p>
<p>卢卡斯定理：组合数，模数很小，逐次拆分<img src="https://img2018.cnblogs.com/blog/1575943/201907/1575943-20190729224246253-1400059291.png" /></p>
<p>乘法逆元，见前面，此处n+1不能保证和p互质，建议用卡特兰数两组合数相减的公式。（不过数据很弱我写的/(n+1)）</p>
<p>##代码</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define db double
#define mod 10007
ll n;
ll gcd(ll a,ll b)&#123;
    return b==0?a:gcd(b,a%b);
&#125;
ll speed(ll a,ll b,ll p)&#123;
    ll cur=a,ans=1;
    while(b)&#123;
        if(b&amp;1) ans=ans*cur%p;
        cur=cur*cur%p;
        b&gt;&gt;=1;
    &#125;
    return ans%p;
&#125;
ll inv(ll t,ll p) &#123;//Inverse element,求t关于p的逆元,注意:t要小于p,最好传参前先把t%p一下 
    return t==1?1:(p-p/t)*inv(p%t,p)%p;
&#125;
ll Scomb(ll _n,ll _m,ll p)&#123;//SmallCombination n,m可以线性求出 
    if(_m==0) return 1;
    //return Factorial(_n,p)*inv(Factorial(m,p)%p,p)%p*inv(Factorial(n-m,p)%p,p)%p;
    ll ans=1,tmp=1;
    for(ll i=_m+1;i&lt;=_n;i++)&#123;
        ans=(ans*i)%p;
    &#125;
    for(ll i=1;i&lt;=_n-_m;i++)&#123;
        tmp=(tmp*i)%p;
    &#125;
    //cout&lt;&lt;tmp&lt;&lt;endl;
    return ans*inv(tmp%p,p)%p;
&#125;
ll Bcomb(ll _n,ll _m,ll p)&#123;//BigCombination
    if(_n&lt;p&amp;&amp;_m&lt;p) return Scomb(_n,_m,p)%p;
    return Bcomb(_n/p,_m/p,p)*Scomb(_n%p,_m%p,p)%p;
&#125;

int main()&#123;
    cin&gt;&gt;n;
    n--;
    ll ans=2*Bcomb(2*n,n,mod)*speed(n+1,mod-2,mod)%mod;
    cout&lt;&lt;ans&lt;&lt;endl;
    //cout&lt;&lt;speed(2,mod-2,mod)%mod;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>51Nod1127 最短的包含字符串</title>
    <url>/2019/10/19/51Nod1127%20%E6%9C%80%E7%9F%AD%E7%9A%84%E5%8C%85%E5%90%AB%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给出一个字符串，求该字符串的一个子串s，s包含A-Z中的全部字母，并且s是所有符合条件的子串中最短的，输出s的长度。如果给出的字符串中并不包括A-Z中的全部字母，则输出No Solution。</p>
<h2 id="solution">Solution</h2>
<p>二分。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">char s[100020];</span><br><span class="line">int len,ans;</span><br><span class="line">int zm[30],cnt;</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    memset(zm,0,sizeof(zm));</span><br><span class="line">    cnt=0;</span><br><span class="line">    for(int i=0;i&lt;x;i++)&#123;</span><br><span class="line">        zm[s[i]-&#x27;A&#x27;]++;</span><br><span class="line">        if(zm[s[i]-&#x27;A&#x27;]==1) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt==26) return true;</span><br><span class="line">    for(int i=x;i&lt;len;i++)&#123;</span><br><span class="line">        zm[s[i]-&#x27;A&#x27;]++;</span><br><span class="line">        if(zm[s[i]-&#x27;A&#x27;]==1) cnt++;</span><br><span class="line">        zm[s[i-x]-&#x27;A&#x27;]--;</span><br><span class="line">        if(zm[s[i-x]-&#x27;A&#x27;]==0) cnt--;</span><br><span class="line">        //printf(&quot;%d : %d\n&quot;,i,cnt);</span><br><span class="line">        if(cnt==26) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    len=strlen(s);</span><br><span class="line">    int l=0,r=len,mid;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line"></span><br><span class="line">        mid=(l+r)/2;//printf(&quot;%d %d\n&quot;,mid,check(mid));</span><br><span class="line">        if(check(mid))&#123;</span><br><span class="line">            r=mid-1;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            l=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans) printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    else printf(&quot;No Solution\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1130斯特林近似</title>
    <url>/2019/02/27/51Nod1130%E6%96%AF%E7%89%B9%E6%9E%97%E8%BF%91%E4%BC%BC/</url>
    <content><![CDATA[<p><img src="https://img2018.cnblogs.com/blog/1575943/201902/1575943-20190227195117036-288323810.jpg" /></p>
<p>log10(n!)=log10(2<em>pi</em>n)<em>0.5+n</em>log10(n/e)</p>
<p>注意long long</p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;cstring&gt;
 4 #include&lt;string&gt;
 5 #include&lt;cmath&gt;
 6 #define ll long long
 7 #define pi 3.1415926535
 8 #define E 2.718281828459
 9 using namespace std;
10 const int mod=1e9+7;
11 int n,x;
12 int main()&#123;
13     cin&gt;&gt;n;
14     for(int i=1;i&lt;=n;i++)&#123;
15         cin&gt;&gt;x;
16         double s=log10(2*pi*x)*0.5+x*(log10(x/E));
17         cout&lt;&lt;(long long)(s)+1&lt;&lt;endl;
18     &#125;
19     return 0;
20 &#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>51Nod1140 矩阵相乘结果的判断</title>
    <url>/2019/10/21/51Nod1140%20%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98%E7%BB%93%E6%9E%9C%E7%9A%84%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给出三个N<em>N的矩阵A, B, C，问A </em> B是否等于C？</p>
<h2 id="solution">Solution</h2>
<p>随机找或者用向量压缩。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int a[520][520],b[520][520],c[520][520];</span><br><span class="line">int r[520],r2[520];</span><br><span class="line">int cr[520],rc[520],br[520],ra[520],abr[520],rab[520];</span><br><span class="line">bool rd()&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	for(int i=1;i&lt;=30000;i++)&#123;</span><br><span class="line">		x=rand()%n+1;</span><br><span class="line">		y=rand()%n+1;</span><br><span class="line">		int sum=0;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			sum+=a[x][j]*b[j][y];</span><br><span class="line">		&#125; </span><br><span class="line">		if(sum!=c[x][y]) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;b[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;c[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		r[i]=i*i%101;</span><br><span class="line">		r2[i]=(i+3)*i%111;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			cr[i]+=c[i][j]*r[j];</span><br><span class="line">			rc[i]+=c[j][i]*r2[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			br[i]+=b[i][j]*r[j];</span><br><span class="line">			ra[i]+=a[j][i]*r2[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			abr[i]+=a[i][j]*br[j];</span><br><span class="line">			rab[i]+=b[j][i]*ra[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bool f=true;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(abr[i]!=cr[i]||rab[i]!=rc[i])&#123;</span><br><span class="line">			f=false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//cout&lt;&lt;rd();</span><br><span class="line">	if(!f)&#123;</span><br><span class="line">		printf(&quot;No\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		//f=f&amp;rd();</span><br><span class="line">		//if(f)&#123;</span><br><span class="line">			printf(&quot;Yes\n&quot;);</span><br><span class="line">		//&#125;</span><br><span class="line">		//else&#123;</span><br><span class="line">			//printf(&quot;No\n&quot;);</span><br><span class="line">		//&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1163 最高的奖励</title>
    <url>/2019/10/12/51Nod1163%20%E6%9C%80%E9%AB%98%E7%9A%84%E5%A5%96%E5%8A%B1/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>有N个任务，每个任务有一个最晚结束时间以及一个对应的奖励。在结束时间之前完成该任务，就可以获得对应的奖励。完成每一个任务所需的时间都是1个单位时间。有时候完成所有任务是不可能的，因为时间上可能会有冲突，这需要你来取舍。求能够获得的最高奖励。</p>
<h2 id="solution">Solution</h2>
<p>时间排序，小根堆，每次加入，如果数量小于时间就加入，否则弹出一个加入。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line"></span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define fo(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define fo0(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">const ll mod = 998244353;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line">db fab(db x) &#123;</span><br><span class="line">    return x &gt; 0 ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">struct E &#123;</span><br><span class="line">    int t, w;</span><br><span class="line"></span><br><span class="line">    bool operator&lt;(const E &amp;x) const &#123;</span><br><span class="line">        return this-&gt;w &gt; x.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[50020];</span><br><span class="line"></span><br><span class="line">int cmp(E x, E y) &#123;</span><br><span class="line">    return x.t &lt; y.t;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;E&gt;q;</span><br><span class="line">int cnt;</span><br><span class="line">ll ans;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    fo(i, 1, n) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;e[i].t, &amp;e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e + 1, e + 1 + n, cmp);</span><br><span class="line">    fo(i,1,n)&#123;</span><br><span class="line">        if(cnt&lt;e[i].t)&#123;</span><br><span class="line">            q.push(e[i]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(e[i].w&gt;q.top().w)&#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(e[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        ans+=q.top().w;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1166 大数开平方</title>
    <url>/2019/10/19/51Nod1166%20%E5%A4%A7%E6%95%B0%E5%BC%80%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给出一个大整数N，求不大于N的平方根的最大整数。例如：N = 8，2 * 2 &lt; 8，3 * 3 &gt; 8，所以输出2。</p>
<h2 id="solution">Solution</h2>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from math import *</span><br><span class="line">from decimal import *</span><br><span class="line">getcontext().prec=10**5</span><br><span class="line">a=input()</span><br><span class="line">print(int(Decimal(a).sqrt()))</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1179 最大的最大公约数</title>
    <url>/2019/11/02/51Nod1179%20%E6%9C%80%E5%A4%A7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给出N个正整数，找出N个数两两之间最大公约数的最大值。例如：N = 4，4个数为：9 15 25 16，两两之间最大公约数的最大值是15同25的最大公约数5。</p>
<h2 id="solution">Solution</h2>
<p>把每个数所有因数搞出来，如果第二次出现就停止。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod=998244353;</span><br><span class="line">int mo(ll a,int p)&#123;</span><br><span class="line">    return a&gt;=p?a%p:a;</span><br><span class="line">&#125;</span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line">int cnt=168;</span><br><span class="line">int pri[200]=&#123;0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,</span><br><span class="line">        53,59,61,67,71,73,79,83,89,97,</span><br><span class="line">        101,103,107,109,113,127,131,137,139,149,</span><br><span class="line">        151,157,163,167,173,179,181,191,193,197,199,</span><br><span class="line">        211,223,227,229,233,239,241,</span><br><span class="line">        251,257,263,269,271,277,281,283,293,</span><br><span class="line">        307,311,313,317,331,337,347,349,</span><br><span class="line">        353,359,367,373,379,383,389,397,</span><br><span class="line">        401,409,419,421,431,433,439,443,449,</span><br><span class="line">        457,461,463,467,479,487,491,499,</span><br><span class="line">        503,509,521,523,541,547,</span><br><span class="line">        557,563,569,571,577,587,593,599,</span><br><span class="line">        601,607,613,617,619,631,641,643,647,</span><br><span class="line">        653,659,661,673,677,683,691,</span><br><span class="line">        701,709,719,727,733,739,743,</span><br><span class="line">        751,757,761,769,773,787,797,</span><br><span class="line">        809,811,821,823,827,829,839,</span><br><span class="line">        853,857,859,863,877,881,883,887,</span><br><span class="line">        907,911,919,929,937,941,947,</span><br><span class="line">        953,967,971,977,983,991,997&#125;;</span><br><span class="line"></span><br><span class="line">int a[50020][30];</span><br><span class="line">int ct[50020][30];</span><br><span class="line">int n,tmp,mx;</span><br><span class="line">int num[50020];</span><br><span class="line">int ans[1000020];</span><br><span class="line">inline int speed(int a,int b)&#123;</span><br><span class="line">    int cur=a,anss=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) anss=anss*cur;</span><br><span class="line">        cur=cur*cur;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return anss;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int t,int cur,int anx)&#123;</span><br><span class="line">    if(cur==a[t][0]+1)&#123;</span><br><span class="line">        ans[anx]++;</span><br><span class="line">        if(ans[anx]&gt;1) mx=max(mx,anx);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;=ct[t][cur];i++)&#123;</span><br><span class="line">        dfs(t,cur+1,anx*speed(a[t][cur],i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num+1,num+1+n);</span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        tmp=num[i];</span><br><span class="line">        for(int j=1;j&lt;=cnt;j++)&#123;</span><br><span class="line">            if(num[i]%pri[j]==0)&#123;</span><br><span class="line">                a[i][++a[i][0]]=pri[j];</span><br><span class="line">            &#125;</span><br><span class="line">            while(num[i]%pri[j]==0)&#123;</span><br><span class="line">                ct[i][a[i][0]]++;</span><br><span class="line">                num[i]/=pri[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(num[i]&gt;1)&#123;</span><br><span class="line">            a[i][++a[i][0]]=num[i];</span><br><span class="line">            ct[i][a[i][0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(mx&gt;=tmp)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;dfs(i,1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,mx);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1225 余数之和</title>
    <url>/2019/10/21/51Nod1225%20%E4%BD%99%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>F(n) = (n % 1) + (n % 2) + (n % 3) + ...... (n % n)。其中%表示Mod，也就是余数。 例如F(6) = 6 % 1 + 6 % 2 + 6 % 3 + 6 % 4 + 6 % 5 + 6 % 6 = 0 + 0 + 0 + 2 + 1 + 0 = 3。 给出n，计算F(n), 由于结果很大，输出Mod 1000000007的结果即可。</p>
<h2 id="solution">Solution</h2>
<p>好像叫分块？不过写的不大好。。。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">typedef __int128 ll;</span><br><span class="line">using namespace std;</span><br><span class="line">ll n;</span><br><span class="line">const ll mod=1000000007;</span><br><span class="line">ll dfs(ll cur,ll cnt)&#123;</span><br><span class="line">	if(cur&lt;=4000000)&#123;</span><br><span class="line">		ll ret=0;</span><br><span class="line">		for(int i=1;i&lt;=cur;i++)&#123;</span><br><span class="line">			ret=(ret+n%i)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	ll nex=n/(cnt+1);</span><br><span class="line">	ll chu=2,num=cur-nex;</span><br><span class="line">	if(num%2==0)&#123;</span><br><span class="line">		chu=1;</span><br><span class="line">		num/=2;</span><br><span class="line">	&#125;</span><br><span class="line">	return ((n%cur+n%(nex+1))/chu%mod*num%mod+dfs(nex,cnt+1))%mod;</span><br><span class="line">&#125;</span><br><span class="line">long long s;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%lld&quot;,&amp;s);</span><br><span class="line">	n=s;</span><br><span class="line">	long long ans=dfs(n,1)%mod;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans); </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1247 可能的路径</title>
    <url>/2019/10/05/51Nod1247%20%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>在一个无限大的二维网格上，你站在(a,b)点上，下一步你可以移动到(a + b, b), (a, a + b), (a - b, b), 或者 (a, a - b)这4个点。 给出起点坐标(a,b)，以及终点坐标(x,y)，问你能否从起点移动到终点。如果可以，输出&quot;Yes&quot;，否则输出&quot;No&quot;。 例如：(1,1) 到 (2,3)，(1,1) -&gt; (2,1) -&gt; (2,3)。</p>
<h2 id="solution">Solution</h2>
<p>1,3操作互逆，2,4同样如此，4，3，2操作可以交换位置，假设前一个大于后一个，前一个可以不断减去后一个知道比后一个小。</p>
<p>这就是一个求gcd，可知gcd相等就能走到。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef __int128 lll;</span><br><span class="line">const lll mod=1e36+1;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">ll T,a,b,x,y;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">        if(gcd(a,b)==gcd(x,y))&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Yes\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout&lt;&lt;&quot;No\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1255 字典序最小的子序列</title>
    <url>/2019/10/12/51Nod1255%20%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给出一个由a-z组成的字符串S，求他的一个子序列，满足如下条件：</p>
<p>1、包含字符串中所有出现过的字符各1个。</p>
<p>2、是所有满足条件1的串中，字典序最小的。</p>
<p>例如：babbdcc，出现过的字符为：abcd，而包含abcd的所有子序列中，字典序最小的为abdc。</p>
<h2 id="solution">Solution</h2>
<p>一个栈，当前没有在栈内，栈顶不是最后一个，且当前更小，就出1个入1个。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line"></span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">const ll mod = 998244353;</span><br><span class="line">const int N = 1e4 + 10;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line">inline ll read() &#123;</span><br><span class="line">    ll data = 0;</span><br><span class="line">    char ch = 0;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) ch = getchar();</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) data = data * 10 + ch - &#x27;0&#x27;, ch = getchar();</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">stack&lt;char&gt;s;</span><br><span class="line">int len;</span><br><span class="line">char x[100020];</span><br><span class="line">bool f[30];</span><br><span class="line">int las[30];</span><br><span class="line">char ans[30];</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%s&quot;,x);</span><br><span class="line">    len=strlen(x);</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        las[x[i]-&#x27;a&#x27;]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        while(!s.empty()&amp;&amp;x[i]&lt;s.top()&amp;&amp;las[s.top()-&#x27;a&#x27;]&gt;i&amp;&amp;!f[x[i]-&#x27;a&#x27;])&#123;</span><br><span class="line">            f[s.top()-&#x27;a&#x27;]=false;</span><br><span class="line">            s.pop();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(!f[x[i]-&#x27;a&#x27;])&#123;</span><br><span class="line">            s.push(x[i]);</span><br><span class="line">            f[x[i]-&#x27;a&#x27;]=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int t=0;</span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">        ans[++t]=s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=t;i&gt;=1;i--)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1265 四点共面</title>
    <url>/2019/10/12/51Nod1265%20%E5%9B%9B%E7%82%B9%E5%85%B1%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给出三维空间上的四个点（点与点的位置均不相同），判断这4个点是否在同一个平面内（4点共线也算共面）。如果共面，输出&quot;Yes&quot;，否则输出&quot;No&quot;。</p>
<h2 id="solution">Solution</h2>
<p>叉积。。。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">const int N = 1e4 + 10;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">const int INF = 1e8;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Vector&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    Vector()&#123;</span><br><span class="line">        x=0,y=0,z=0;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">struct Point&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    Point()&#123;</span><br><span class="line">        x=0,y=0,z=0;</span><br><span class="line">    &#125;</span><br><span class="line">    void Input()&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Vector cromul(Vector a1,Vector a2)&#123;</span><br><span class="line">    Vector tmp;</span><br><span class="line">    tmp.x=a1.y*a2.z-a1.z*a2.y;</span><br><span class="line">    tmp.y=a1.z*a2.x-a1.x*a2.z;</span><br><span class="line">    tmp.z=a1.x*a2.y-a1.y*a2.x;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">Vector ptv(Point a1,Point a2)&#123;</span><br><span class="line">    Vector tmp;</span><br><span class="line">    tmp.x=a2.x-a1.x;</span><br><span class="line">    tmp.y=a2.y-a1.y;</span><br><span class="line">    tmp.z=a2.z-a1.z;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">int pmul(Vector a1,Vector a2)&#123;</span><br><span class="line">    return a1.x*a2.x+a1.y*a2.y+a1.z*a2.z;</span><br><span class="line">&#125;</span><br><span class="line">Point p[6];</span><br><span class="line">Vector v[10];</span><br><span class="line">int T;</span><br><span class="line">int main() &#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        for(int i=1;i&lt;=4;i++)&#123;</span><br><span class="line">            p[i].Input();</span><br><span class="line">        &#125;</span><br><span class="line">        v[1]=ptv(p[1],p[2]);</span><br><span class="line">        v[2]=ptv(p[1],p[3]);</span><br><span class="line">        v[3]=ptv(p[1],p[4]);</span><br><span class="line">        v[4]=cromul(v[1],v[2]);</span><br><span class="line">        if(pmul(v[3],v[4])==0)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Yes\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout&lt;&lt;&quot;No\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1267 4个数和为0</title>
    <url>/2019/07/29/51Nod1267%204%E4%B8%AA%E6%95%B0%E5%92%8C%E4%B8%BA0/</url>
    <content><![CDATA[<p>##题目</p>
<p>给出N个整数，你来判断一下是否能够选出4个数，他们的和为0，可以则输出&quot;Yes&quot;，否则输出&quot;No&quot;。 n&lt;=1e3</p>
<p>##思路</p>
<p>《挑战程序设计竞赛》的经典题，预处理两层+二分</p>
<p>##代码</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
ll n,a[1020],ct;
struct E&#123;
    ll w;
    int p1,p2;
&#125;e[600020];
int cmp(E x,E y)&#123;
    return x.w&lt;y.w;
&#125;
int main()&#123;
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)&#123;
        scanf(&quot;%lld&quot;,&amp;a[i]);
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        for(int j=i+1;j&lt;=n;j++)&#123;
            e[++ct]=(E)&#123;a[i]+a[j],i,j&#125;;
        &#125;
    &#125;
    sort(e+1,e+1+ct,cmp);
    for(int i=1;i&lt;=n;i++)&#123;
        for(int j=i+1;j&lt;=n;j++)&#123;
            int l=1,r=ct,mid;
            while(l&lt;=r)&#123;
                mid=(l+r)&gt;&gt;1;
                if(a[i]+a[j]+e[mid].w&lt;0)&#123;
                    l=mid+1;
                &#125;
                else&#123;
                    r=mid-1;
                &#125;
            &#125;
            for(int k=l;a[i]+a[j]+e[k].w==0;k++)&#123;
                if(i!=e[k].p1&amp;&amp;i!=e[k].p2&amp;&amp;j!=e[k].p1&amp;&amp;j!=e[k].p2)&#123;
                    printf(&quot;Yes\n&quot;);
                    return 0;
                &#125;
            &#125;
        &#125;
    &#125;
    printf(&quot;No\n&quot;);
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>51Nod1272 最大距离</title>
    <url>/2019/10/19/51Nod1272%20%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给出一个长度为N的整数数组A，对于每一个数组元素，如果他后面存在大于等于该元素的数，则这两个数可以组成一对。每个元素和自己也可以组成一对。例如：{5, 3, 6, 3, 4, 2}，可以组成11对，如下（数字为下标）： (0,0), (0, 2), (1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (3, 3), (3, 4), (4, 4), (5, 5)。其中(1, 4)是距离最大的一对，距离为3。</p>
<h2 id="solution">Solution</h2>
<p>二分距离，后缀最大值优化检验。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">int n,a[50020],ans;</span><br><span class="line">int mx[50020];</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    //printf(&quot;%d\n&quot;,x);</span><br><span class="line">    for(int i=1;i+x&lt;=n;i++)&#123;</span><br><span class="line">        if(a[i]&lt;=mx[i+x])&#123;</span><br><span class="line">            //printf(&quot;%d %d\n&quot;,i,i+x);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int max(int x,int y)&#123;</span><br><span class="line">    return x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        mx[i]=max(mx[i+1],a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int l=0,r=n-1,mid;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)/2;</span><br><span class="line">        if(check(mid))&#123;</span><br><span class="line">            l=mid+1;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            r=mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1279 扔盘子</title>
    <url>/2019/07/24/51Nod1279%20%E6%89%94%E7%9B%98%E5%AD%90/</url>
    <content><![CDATA[<p>##题目 有一口井，井的高度为N，每隔1个单位它的宽度有变化。现在从井口往下面扔圆盘，如果圆盘的宽度大于井在某个高度的宽度，则圆盘被卡住（恰好等于的话会下去）。</p>
<p>盘子有几种命运：1、掉到井底。2、被卡住。3、落到别的盘子上方。</p>
<p>盘子的高度也是单位高度。给定井的宽度和每个盘子的宽度，求最终落到井内的盘子数量。</p>
<p>##思路 小口下面的大口没用，让井变递减，n+m匹配</p>
<p>##代码 #include&lt;bits/stdc++.h&gt; #define ll long long #define db double using namespace std; int n,m; int w[50020],d[50020]; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%d&quot;,&amp;w[1]); for(int i=2;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;w[i]); if(w[i]&gt;w[i-1]) w[i]=w[i-1]; } for(int i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;d[i]); } int p=n,ans=0; for(int i=1;i&lt;=m&amp;&amp;p&gt;0;i++){ while(p&gt;0){ if(d[i]&lt;=w[p]){ break; } else{ p--; } } if(p==0) break; ans++; p--; } cout&lt;&lt;ans&lt;&lt;endl; return 0; }</p>
]]></content>
  </entry>
  <entry>
    <title>51Nod1278 相离的圆</title>
    <url>/2019/10/03/51Nod1278%20%E7%9B%B8%E7%A6%BB%E7%9A%84%E5%9C%86/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>平面上有N个圆，他们的圆心都在X轴上，给出所有圆的圆心和半径，求有多少对圆是相离的。</p>
<p>例如：4个圆分别位于1, 2, 3, 4的位置，半径分别为1, 1, 2, 1，那么{1, 2}, {1, 3} {2, 3} {2, 4} {3, 4}这5对都有交点，只有{1, 4}是相离的。</p>
<h2 id="solution">Solution</h2>
<p>注意圆心在坐标轴上，之前因为没看到这句话把题跳了。 然后就可以转化为线段，按照左端点排序，i代表线段循环，二分求左端点在第i条线段右端点左边的最后一个线段，他后面的线段就是相离的，加入答案。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define io_opt std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">int n,ans;</span><br><span class="line">struct E&#123;</span><br><span class="line">	int s,t;</span><br><span class="line">&#125;e[50020];</span><br><span class="line">int cmp(E x,E y)&#123;</span><br><span class="line">	if(x.s==y.s) return x.t&lt;y.t;</span><br><span class="line">	return x.s&lt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//io_opt;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int x,r;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;x,&amp;r);</span><br><span class="line">		e[i].s=x-r;</span><br><span class="line">		e[i].t=x+r;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(e+1,e+1+n,cmp);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int l=i,r=n,mid,tmp=i;</span><br><span class="line">		while(l&lt;=r)&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;1;</span><br><span class="line">			if(e[mid].s&lt;=e[i].t)&#123;</span><br><span class="line">				l=mid+1;</span><br><span class="line">				tmp=mid;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				r=mid-1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=n-tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1285 山峰和分段</title>
    <url>/2019/10/19/51Nod1285%20%E5%B1%B1%E5%B3%B0%E5%92%8C%E5%88%86%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>用一个长度为N的整数数组A，描述山峰和山谷的高度。山峰需要满足如下条件， 0 &lt; P &lt; N - 1 且 A[P - 1] &lt; A[P] &gt; A[P + 1]。</p>
<p>现在要将整个山分为K段，要求每段的点数都一样，且每段中都至少存在一个山峰，问最多可以分为多少段。</p>
<h2 id="solution">Solution</h2>
<p>枚举因数，前缀和优化查询。</p>
<p>复杂度是因子之和，试了一下，1e6之内一个大于5*n的也没有，最大比率4.5多一点。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int a[50020];</span><br><span class="line">int sum[50020];</span><br><span class="line">int main() &#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i&lt;=n-1;i++)&#123;</span><br><span class="line">        if(a[i]&gt;a[i-1]&amp;&amp;a[i]&gt;a[i+1])&#123;</span><br><span class="line">            sum[i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[i]+=sum[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[n]=sum[n-1];</span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            bool fg=true;</span><br><span class="line">            int l=n/i;</span><br><span class="line">            for(int j=1;j&lt;=i;j++)&#123;</span><br><span class="line">                if(sum[j*l]-sum[(j-1)*l]&lt;1)&#123;</span><br><span class="line">                    fg=false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(fg)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1287 加农炮</title>
    <url>/2019/10/12/51Nod1287%20%E5%8A%A0%E5%86%9C%E7%82%AE/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>一个长度为M的正整数数组A，表示从左向右的地形高度。测试一种加农炮，炮弹平行于地面从左向右飞行，高度为H，如果某处地形的高度大于等于炮弹飞行的高度H（A[i] &gt;= H），炮弹会被挡住并落在i - 1处，则A[i - 1] + 1。如果H &lt;= A[0]，则这个炮弹无效，如果H &gt; 所有的A[i]，这个炮弹也无效。现在给定N个整数的数组B代表炮弹高度，计算出最后地形的样子。</p>
<p>例如：地形高度A = {1, 2, 0, 4, 3, 2, 1, 5, 7}, 炮弹高度B = {2, 8, 0, 7, 6, 5, 3, 4, 5, 6, 5}，最终得到的地形高度为：{2, 2, 2, 4, 3, 3, 5, 6, 7}。</p>
<h2 id="solution">Solution</h2>
<p>1e6数组存每个高度的炮弹能打到的位置，每次更新。</p>
<p>另一种是维护前缀最大值，因为每次前一个+1之后仍然&lt;=后一个，O（1）维护即可。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">const int N = 1e4 + 10;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">const int INF = 1e8;</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">int a[50020],b[50020];</span><br><span class="line">int t[1000020];</span><br><span class="line">int main() &#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        for(int j=a[i];j&gt;=0&amp;&amp;t[j]==0;j--)&#123;</span><br><span class="line">            t[j]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        if(b[i]&gt;a[1])&#123;</span><br><span class="line">            a[t[b[i]]-1]++;</span><br><span class="line">            if(t[b[i]]-1&lt;t[a[t[b[i]]-1]])&#123;</span><br><span class="line">                t[a[t[b[i]]-1]]=t[b[i]]-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1403 有趣的堆栈</title>
    <url>/2019/11/02/51Nod1403%20%E6%9C%89%E8%B6%A3%E7%9A%84%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>大家都熟悉堆栈操作。一个堆栈一般有两种操作，push和pop。假设所有操作都是合法的并且最终堆栈为空。我们可以有很多方法记录堆栈的操作， （1） 对每个pop操作，我们记录它之前一共有多少个push操作。 （2） 对每个pop操作，我们记录这个被Pop的元素曾经被压上了几个。 例如：操作push, push, pop, push, push, pop, push, pop, pop, pop 用第一种方法 记录为 2, 4, 5, 5, 5 用第二种方法 记录为 0, 0, 0, 2, 4 这两种记录方法可以互相转化，我们的问题是，给定第二种记录方法的序列，请求出第一种记录方法的序列。</p>
<h2 id="solution">Solution</h2>
<p>第i个位置变成i，然后扫到几，就在他前面几个数上加1，我也不知道为啥，推出来的。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">const int mod=998244353;</span><br><span class="line">int mo(ll a,int p)&#123;</span><br><span class="line">    return a&gt;=p?a%p:a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line">int n,x;</span><br><span class="line">int f[1000020];</span><br><span class="line">char pbuf[100000],*pp=pbuf;</span><br><span class="line">void push(const char c) &#123;</span><br><span class="line">    if(pp-pbuf==100000) fwrite(pbuf,1,100000,stdout),pp=pbuf;</span><br><span class="line">    *pp++=c;</span><br><span class="line">&#125;</span><br><span class="line">void write(int x) &#123;</span><br><span class="line">    static int sta[35];</span><br><span class="line">    int top=0;</span><br><span class="line">    do&#123;sta[top++]=x%10,x/=10;&#125;while(x);</span><br><span class="line">    while(top) push(sta[--top]+&#x27;0&#x27;);</span><br><span class="line">    push(&#x27; &#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    n=rd();</span><br><span class="line">    for(register int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        x=rd();</span><br><span class="line">        if(x)&#123;</span><br><span class="line">            f[i-x-1]++;</span><br><span class="line">            f[i-1]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    register int las=0;</span><br><span class="line">    for(register int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        las=1+las+f[i-1];</span><br><span class="line">        write(las);</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(pbuf,1,pp-pbuf,stdout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1417 天堂里的游戏</title>
    <url>/2019/10/04/51Nod1417%20%E5%A4%A9%E5%A0%82%E9%87%8C%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>正当Noder惊魂未定的时候，走来一个美女，要求和他一起玩个数学游戏。美女提议：“让我们各自亮出硬币的一面，或正或反。如果我们都是正面，那么我给你A元，如果我们都是反面，我给你B元（A + B为偶数）。剩下的情况你给我（A + B） / 2元就可以了。</p>
<p>Noder知道这个游戏他多半要输，可他并不在乎，他只想让自己输的慢一点。</p>
<p>那么你来帮美女计算一下，她选择出正面的概率应该是多少（以最简分数形式输出）？</p>
<h2 id="solution">Solution</h2>
<p>混合策略纳什平衡，详见<a href="https://baike.baidu.com/item/%E7%BA%B3%E4%BB%80%E5%B9%B3%E8%A1%A1/1325910?fr=aladdin">纳什平衡-百度百科</a></p>
<p>设你出正面和反面概率是x,(1-x)，美女出正面和反面概率是y,(1-y)。列表，写出美女出正面，你的期望收益，美女出反面，你的期望收益，让两者相等，否则美女可以通过改变她的概率来使你的期望收益降低。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">美女</th>
<th style="text-align: center;">正面</th>
<th style="text-align: center;">反面</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">正面</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">-(A+B)/2</td>
</tr>
<tr class="even">
<td style="text-align: center;">反面</td>
<td style="text-align: center;">-(A+B)/2</td>
<td style="text-align: center;">B</td>
</tr>
</tbody>
</table>
<p>A * x - (A+B)/2 * (1-x) = -(A+B)/2 * x + B * ( 1-x )</p>
<p>解出x = (a+3b) / 4(a+b)</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mod 998244353LL</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define ll long long</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">ll lowspeed(ll a,ll b,ll p)&#123;ll cur=a,ans=0;while(b)&#123;if(b&amp;1) ans=(ans+cur)%p;cur=(cur+cur)%p;b&gt;&gt;=1;&#125;return ans%p;&#125;</span><br><span class="line">ll speed(ll a,ll b,ll p)&#123;ll cur=a,ans=1;while(b)&#123;if(b&amp;1) ans=lowspeed(ans,cur,p)%p;cur=lowspeed(cur,cur,p)%p;b&gt;&gt;=1;&#125;return ans%p;&#125;</span><br><span class="line">ll T,A,B;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cin&gt;&gt;A&gt;&gt;B;</span><br><span class="line">        ll x=A+3*B;</span><br><span class="line">        ll y=4*(A+B);</span><br><span class="line">        ll gd=gcd(x,y);</span><br><span class="line">        cout&lt;&lt;x/gd&lt;&lt;&#x27;/&#x27;&lt;&lt;y/gd&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1435 位数阶乘</title>
    <url>/2019/10/19/51Nod1435%20%E4%BD%8D%E6%95%B0%E9%98%B6%E4%B9%98/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>X是一个n位数的正整数 (𝑥=𝑎0𝑎1...𝑎𝑛−1)</p>
<p>现在定义 F(x)=∏𝑖=0𝑛−1(𝑎𝑖!) ， 比如F(135)=1!<em>3!</em>5!=720.</p>
<p>我们给定一个n位数的整数X(至少有一位数大于1，X中可能有前导0)，</p>
<p>然后我们去找一个正整数(s)符合以下条件：</p>
<p>1.这个数尽可能大，</p>
<p>2.这个数中不能含有数字0或1。</p>
<p>3.F(s)=F(x)</p>
<h2 id="solution">Solution</h2>
<p>把2到9阶乘拆开，发现质因子7的时候必选7或8或9，但8和9能拆开，这样数位更多，更优，向下同理，因此拆成2，3，5，7组成的即可。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll tp,n;</span><br><span class="line">int sum[7];</span><br><span class="line">int num[7]=&#123;2,3,5,7&#125;;</span><br><span class="line">int ans[7];</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;tp&gt;&gt;n;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        int tmp=n%10;</span><br><span class="line">        switch(tmp)&#123;</span><br><span class="line">            case 2:sum[0]+=1;break;</span><br><span class="line">            case 3:sum[0]+=1;sum[1]+=1;break;</span><br><span class="line">            case 4:sum[0]+=3;sum[1]+=1;break;</span><br><span class="line">            case 5:sum[0]+=3;sum[1]+=1;sum[2]+=1;break;</span><br><span class="line">            case 6:sum[0]+=4;sum[1]+=2;sum[2]+=1;break;</span><br><span class="line">            case 7:sum[0]+=4;sum[1]+=2;sum[2]+=1;sum[3]+=1;break;</span><br><span class="line">            case 8:sum[0]+=7;sum[1]+=2;sum[2]+=1;sum[3]+=1;break;</span><br><span class="line">            case 9:sum[0]+=7;sum[1]+=4;sum[2]+=1;sum[3]+=1;break;</span><br><span class="line">            default:break;</span><br><span class="line">        &#125;</span><br><span class="line">        n/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[3]+=sum[3];</span><br><span class="line">    sum[2]-=sum[3];</span><br><span class="line">    sum[1]-=sum[3]*2;</span><br><span class="line">    sum[0]-=sum[3]*4;</span><br><span class="line">    ans[2]+=sum[2];</span><br><span class="line">    sum[1]-=sum[2];</span><br><span class="line">    sum[0]-=sum[2]*3;</span><br><span class="line">    ans[1]+=sum[1];</span><br><span class="line">    sum[0]-=sum[1];</span><br><span class="line">    ans[0]+=sum[0];</span><br><span class="line">    for(int i=3;i&gt;=0;i--)&#123;</span><br><span class="line">        for(int j=1;j&lt;=ans[i];j++)&#123;</span><br><span class="line">            cout&lt;&lt;num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1496 最小异或和</title>
    <url>/2019/10/23/51Nod1496%20%E6%9C%80%E5%B0%8F%E5%BC%82%E6%88%96%E5%92%8C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>一个集合包含一组相互不同的数字。现在我们要去寻找一个集合，他要满足如下性质：</p>
<p>对于所有 𝑥(𝑥∈𝑆) ，要满足l ≤ x ≤ r;</p>
<p>1 ≤ |S| ≤ k;</p>
<p>设S中第i个元素是 𝑠𝑖 ;那么 𝑓(𝑆)=𝑠1 ⨁ 𝑠2 ⨁ ... ⨁ 𝑠|𝑆| 的值要尽可能小。</p>
<h2 id="solution">Solution</h2>
<p>k=1，答案为l。</p>
<p>k=2，如果偶数-奇数存在为1，但有特殊情况，答案为两者异或和和两个数取最小。</p>
<p>k=3，至少有三个连续的数，则必然&lt;=1，只需要找是否为0，两个数异或不可能为0，考虑l的最高位，记为第i位，如果要全消除，则另外两个数第i位必有1个1，1个0，又第i位为0的数不可能比l小，则此数i+1位为1，那么第i位为1的数第i+1位也为1。</p>
<p>即： 1 1 0 0 0 0 0 0 1 0 X X X X X X 1 X X X X X X ——左边界l</p>
<p>k=4，如果可以选择的数大于4个直接为0，否则4个数暴力找。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll l, r, k;</span><br><span class="line">ll a[10];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">    if (k == 1) &#123;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125; else if (k == 2) &#123;</span><br><span class="line">        if (r - l + 1 == 2) &#123;</span><br><span class="line">            cout &lt;&lt; min(l, min(r, l ^ r));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (k == 3) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        while (l) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            l &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((3LL &lt;&lt; (cnt - 1)) &lt;= r) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (r - l + 1 &gt; 4) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a[1] = l, a[2] = l + 1, a[3] = l + 2, a[4] = l + 3;</span><br><span class="line">            ll ans = 1;</span><br><span class="line">            ans = min(ans, a[1] ^ a[2] ^ a[3]);</span><br><span class="line">            ans = min(ans, a[1] ^ a[2] ^ a[4]);</span><br><span class="line">            ans = min(ans, a[1] ^ a[3] ^ a[4]);</span><br><span class="line">            ans = min(ans, a[4] ^ a[2] ^ a[3]);</span><br><span class="line">            ans = min(ans, a[1] ^ a[2] ^ a[3] ^ a[4]);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1536 不一样的猜数游戏</title>
    <url>/2019/10/19/51Nod1536%20%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>瓦斯亚和皮台亚在玩一个简单的游戏。瓦斯亚心中想一个整数x，它是1到n之间的整数。然后皮台亚尝试着猜这个数字。</p>
<p>皮台亚每次问一个形如这样的问题：这个x是y的倍数吗？</p>
<p>这个游戏的流程是这样的：首先皮台亚把所有他想问的形如上述的问题都问出来（当然他也可以不问任何问题），然后瓦斯亚针对每一个问题给出yes或no的答案。最后皮台亚根据这些问题推断出瓦斯亚心中所想的x是哪个数字。</p>
<p>现在皮台亚想知道他最少要问多少个问题才能猜出1到n之间的那个数字。也就是说不管x是1到n之间的哪个数字只要问那些问题就能够确定那个数字了。</p>
<p>样例解释：</p>
<p>可以问是否是2，3，4这些数字倍数的三个问题。</p>
<p>如果都不是，说明是1.</p>
<p>如果是4的倍数，说明是4.</p>
<p>如果是3的倍数说明是3.</p>
<p>否则就是2。</p>
<p>没有比这更少的问题数目了。</p>
<h2 id="solution">Solution</h2>
<p>n以内所有质数以及他们不超过n的次方都要问。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">const int MAXN=1e3;</span><br><span class="line">bool ipr[MAXN+20];</span><br><span class="line">int cnt,pri[MAXN/5];</span><br><span class="line">void prime()&#123;//∞£ Ω…∏∑®</span><br><span class="line">    int N=sqrt(MAXN)+0.5,mul;</span><br><span class="line">    memset(ipr,true,sizeof(ipr));</span><br><span class="line">    ipr[1]=false;</span><br><span class="line">    for(int i=2;i&lt;=N;i++)&#123;</span><br><span class="line">        if(ipr[i]==true)&#123;</span><br><span class="line">            i==2?mul=1:mul=2;</span><br><span class="line">            for(int j=i*i;j&lt;=MAXN;j+=i*mul)&#123;</span><br><span class="line">                ipr[j]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i&lt;=MAXN;i++)&#123;</span><br><span class="line">        if(ipr[i]==true)&#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">    prime();</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=cnt&amp;&amp;pri[i]&lt;=n;i++)&#123;</span><br><span class="line">        int cur=1;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            cur*=pri[i];</span><br><span class="line">            if(cur&lt;=n) ans++;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1548 欧姆诺姆和糖果</title>
    <url>/2019/10/19/51Nod1548%20%E6%AC%A7%E5%A7%86%E8%AF%BA%E5%A7%86%E5%92%8C%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>一天，欧姆诺诺姆来到了朋友家里，他发现了许多糖果。有蓝色和红色两种。他知道每颗红色糖果重Wr克，每颗蓝色糖果重Wb克。吃一颗蓝色糖果会给他带来Hb的欢乐值，吃一颗红色糖果会给他带来Hr的欢乐值。</p>
<p>欧姆诺姆最多只能吃C克的糖果，而且每一颗糖果不能只吃一半。现在他想通过吃蓝色和红色的糖果来获得最大的欢乐值。</p>
<p>样例解释：每一种糖果吃两颗即可。</p>
<h2 id="solution">Solution</h2>
<p>我是水过去的，直接全选单位价值最高的，然后向下枚举。</p>
<p>证明见解题报告。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll w[10],h[10];</span><br><span class="line">ll c;</span><br><span class="line">int main() &#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;c&gt;&gt;h[1]&gt;&gt;h[2]&gt;&gt;w[1]&gt;&gt;w[2];</span><br><span class="line">    db x1=(db)h[1]/w[1],x2=(db)h[2]/w[2];</span><br><span class="line">    if(x1&lt;x2)&#123;</span><br><span class="line">        swap(h[1],h[2]);</span><br><span class="line">        swap(w[1],w[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll x=c/w[1],y=(c-x*w[1])/w[2];</span><br><span class="line">    ll ans=x*h[1]+y*h[2];</span><br><span class="line">    for(int i=1;i&lt;=100000&amp;&amp;x-i&gt;=0;i++)&#123;</span><br><span class="line">        ll xx=x-i,yy=(c-xx*w[1])/w[2];</span><br><span class="line">        ans=max(ans,xx*h[1]+yy*h[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1562 玻璃切割</title>
    <url>/2019/10/12/51Nod1562%20%E7%8E%BB%E7%92%83%E5%88%87%E5%89%B2/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>现在有一块玻璃，是长方形的（w 毫米× h 毫米），现在要对他进行切割。</p>
<p>切割的方向有两种，横向和纵向。每一次切割之后就会有若干块玻璃被分成两块更小的玻璃。在切割之后玻璃不会被移动。</p>
<p>现在想知道每次切割之后面积最大的一块玻璃是多少。</p>
<h2 id="solution">Solution</h2>
<p>倒着做。</p>
<p>做法1:</p>
<p>multiset，每次删除之后维护两端最大值。</p>
<p>做法2:</p>
<p>并查集维护。</p>
<h2 id="code1">Code1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int w,h,n;</span><br><span class="line">multiset&lt;int&gt;msh;</span><br><span class="line">multiset&lt;int&gt;msv;</span><br><span class="line">typedef multiset&lt;int&gt;::iterator mtpoi;</span><br><span class="line">struct E&#123;</span><br><span class="line">	bool is_x;</span><br><span class="line">	int t;</span><br><span class="line">&#125;e[200020];</span><br><span class="line">char s[10];</span><br><span class="line">int cnt1,cnt2,a[200020],b[200020];</span><br><span class="line">int x;</span><br><span class="line">ll ans[200020];</span><br><span class="line">int main()&#123;</span><br><span class="line">	//printf(&quot;%f&quot;,log2(200000));</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;h,&amp;w,&amp;n);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		scanf(&quot;%s%d&quot;,s,&amp;x);</span><br><span class="line">		if(s[0]==&#x27;H&#x27;)&#123;</span><br><span class="line">			e[i].is_x=true;</span><br><span class="line">			a[++cnt1]=x;</span><br><span class="line">			msh.insert(x);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			e[i].is_x=false;</span><br><span class="line">			b[++cnt2]=x;</span><br><span class="line">			msv.insert(x);</span><br><span class="line">			//printf(&quot;%d\n&quot;,x);</span><br><span class="line">		&#125;</span><br><span class="line">		e[i].t=x;</span><br><span class="line">	&#125;</span><br><span class="line">	msh.insert(0);</span><br><span class="line">	msh.insert(w);</span><br><span class="line">	msv.insert(0);</span><br><span class="line">	msv.insert(h);</span><br><span class="line">	sort(a+1,a+1+cnt1);</span><br><span class="line">	sort(b+1,b+1+cnt2);</span><br><span class="line">	a[cnt1+1]=w;</span><br><span class="line">	b[cnt2+1]=h;</span><br><span class="line">	int mxh=0,mxv=0;</span><br><span class="line">	for(int i=1;i&lt;=cnt1+1;i++)&#123;</span><br><span class="line">		mxh=max(mxh,a[i]-a[i-1]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=cnt2+1;i++)&#123;</span><br><span class="line">		mxv=max(mxv,b[i]-b[i-1]);</span><br><span class="line">	&#125;</span><br><span class="line">	ans[1]=mxh;</span><br><span class="line">	ans[1]*=mxv;</span><br><span class="line"></span><br><span class="line">	for(int i=n;i&gt;=2;i--)&#123;</span><br><span class="line">		if(e[i].is_x==true)&#123;</span><br><span class="line">			msh.erase(e[i].t);</span><br><span class="line">			mtpoi r=msh.upper_bound(e[i].t);</span><br><span class="line">			mtpoi l=r;</span><br><span class="line">			l--;</span><br><span class="line">			mxh=max(mxh,*r-*l);//puts(&quot;1&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			msv.erase(e[i].t);</span><br><span class="line">			//printf(&quot;del %d\n&quot;,e[i].t);</span><br><span class="line">			mtpoi r=msv.upper_bound(e[i].t);</span><br><span class="line">			mtpoi l=r;</span><br><span class="line">			l--;</span><br><span class="line">			mxv=max(mxv,*r-*l);</span><br><span class="line">			//printf(&quot;%d %d\n&quot;,*l,*r);</span><br><span class="line">		&#125;</span><br><span class="line">		ans[n-i+2]=mxh;</span><br><span class="line">		ans[n-i+2]*=mxv;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code2">Code2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define fo(d,s,t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define fo0(d,s,t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    char c = getchar(); int x = 0, f = 1;</span><br><span class="line">    while(c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123;if(c == &#x27;-&#x27;) f = -1; c = getchar();&#125;</span><br><span class="line">    while(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;, c = getchar();</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line">int w,h,n;</span><br><span class="line">struct E&#123;</span><br><span class="line">	int l,r;</span><br><span class="line">&#125;;</span><br><span class="line">E ww[200020],hh[200020];</span><br><span class="line">int wx[200020],hx[200020];</span><br><span class="line">char s1[20];</span><br><span class="line">int s2,cnt1,cnt2;</span><br><span class="line">struct S&#123;</span><br><span class="line">	char x;</span><br><span class="line">	int t;</span><br><span class="line">&#125;;</span><br><span class="line">S cur[200020];</span><br><span class="line">ll ans=0;</span><br><span class="line">ll anss[200020];</span><br><span class="line">int main()&#123;</span><br><span class="line">	w=rd();h=rd();n=rd();</span><br><span class="line">	//getchar();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    	s1[0]=getchar();</span><br><span class="line">    	s2=rd();</span><br><span class="line">    	//getchar();</span><br><span class="line">    	cur[i].x=s1[0];</span><br><span class="line">    	cur[i].t=s2;</span><br><span class="line">    	if(s1[0]==&#x27;H&#x27;)&#123;</span><br><span class="line">    		hx[++cnt1]=s2;</span><br><span class="line">    	&#125;</span><br><span class="line">    	else&#123;</span><br><span class="line">    		wx[++cnt2]=s2;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(hx+1,hx+1+cnt1);</span><br><span class="line">    sort(wx+1,wx+1+cnt2);</span><br><span class="line">    hx[cnt1+1]=h;</span><br><span class="line">    wx[cnt2+1]=w;</span><br><span class="line">    int mxh=0,mxw=0;</span><br><span class="line">    for(int i=1;i&lt;=cnt1+1;i++)&#123;</span><br><span class="line">    	if(i&lt;=cnt1)hh[hx[i]].l=hx[i-1];</span><br><span class="line">    	if(i&lt;=cnt1)hh[hx[i]].r=hx[i+1];</span><br><span class="line">    	mxh=max(mxh,hx[i]-hx[i-1]);</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=cnt2+1;i++)&#123;</span><br><span class="line">    	if(i&lt;=cnt2)ww[wx[i]].l=wx[i-1];</span><br><span class="line">    	if(i&lt;=cnt2)ww[wx[i]].r=wx[i+1];</span><br><span class="line">    	mxw=max(mxw,wx[i]-wx[i-1]);//</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">    	ans=mxw;</span><br><span class="line">    	ans*=mxh;</span><br><span class="line">    	anss[i]=ans;</span><br><span class="line">    	if(cur[i].x==&#x27;H&#x27;)&#123;</span><br><span class="line">    		int tmp1,tmp2;</span><br><span class="line">    		tmp1=hh[hh[cur[i].t].l].r=hh[cur[i].t].r;</span><br><span class="line">    		tmp2=hh[hh[cur[i].t].r].l=hh[cur[i].t].l;</span><br><span class="line">    		mxh=max(tmp1-tmp2,mxh);//printf(&quot;-%d\n&quot;,mxh);</span><br><span class="line">    	&#125;</span><br><span class="line">    	else&#123;</span><br><span class="line">    		int tmp1,tmp2;</span><br><span class="line">    		tmp1=ww[ww[cur[i].t].l].r=ww[cur[i].t].r;</span><br><span class="line">    		tmp2=ww[ww[cur[i].t].r].l=ww[cur[i].t].l;</span><br><span class="line">    		mxw=max(tmp1-tmp2,mxw);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    	printf(&quot;%lld\n&quot;,anss[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1621 花钱买车牌</title>
    <url>/2019/10/21/51Nod1621%20%E8%8A%B1%E9%92%B1%E4%B9%B0%E8%BD%A6%E7%89%8C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>一个车牌号由n位数字组成。如果一个车牌至少有k位数字是相同的，那么我们就说这个车牌漂亮的车牌。现在华沙想要改变他自己的车牌，使得他的车牌变得漂亮。当然，改车牌是要花钱的。每改变一位数字所要花费的费用等于当前位上的新旧数字之差的绝对值。那么总费用就是每位上所花费用的总和。</p>
<p>举例如下，</p>
<p>旧牌为0123，新牌为7765，那么对应第一位所花费用为|0-7|＝7，第二位为|1-7|＝6，第三位为|2-6|＝4，第四位为|3-5|＝2，总和为7+6+4+2＝19</p>
<p>华沙想用最少的钱，使他的车牌变得漂亮起来。现在给定n，k，和旧牌的号码，计算换牌的最少费，以及新牌的号码，</p>
<p>如果最少费用的号码有多个，我们取字典序最小的那个。</p>
<p>样例解释：</p>
<p>在样例中，把第二个数字换成“8”花费|9-8|＝1，把第五个数字换成“8”也花了1。</p>
<p>把第六个数字换成“8”花费|6-8|＝2.总费用为1+1+2＝4，新号码为“888188”</p>
<p>两个长度为n的序列比较方法如下。</p>
<p>存在两个序列x，y，长度都是n。</p>
<p>如果存在i(1≤i≤n)和任意j(1≤j＜i)使得 xi＜yixi＜yi 并且 xj＝yjxj＝yj ，那么我们就说x比y小。</p>
<h2 id="solution">Solution</h2>
<p>0到9循环，每次排序改变前面的。</p>
<p>排序规则，先排差绝对值小的，相等先排数大的，这样字典序会改小，数还相等，如果小于当前循环的i，说明字典序会变大，就先排后面的，否则先排前面的。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">int n,k;</span><br><span class="line">struct E&#123;</span><br><span class="line">	char c;</span><br><span class="line">	int pla;</span><br><span class="line">&#125;e[10020];</span><br><span class="line">E ans[10020];</span><br><span class="line">E cur[10020];</span><br><span class="line">int mn=1e9;</span><br><span class="line">bool Ecmp(E x[],E y[])&#123;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(x[i].c&lt;y[i].c) return false;</span><br><span class="line">		else if(x[i].c&gt;y[i].c) return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">void cpy(E x[],E y[])&#123;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		x[i]=y[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">string s;</span><br><span class="line">int tmp=0;</span><br><span class="line">int ab(int x)&#123;</span><br><span class="line">	return x&gt;0?x:-x;</span><br><span class="line">&#125;</span><br><span class="line">int cmp(E x,E y)&#123;</span><br><span class="line">	int xx=x.c-&#x27;0&#x27;,yy=y.c-&#x27;0&#x27;;</span><br><span class="line">	if(ab(xx-tmp)==ab(yy-tmp))&#123;</span><br><span class="line">		if(xx==yy)&#123;</span><br><span class="line">			if(xx&gt;tmp)&#123;</span><br><span class="line">				return x.pla&lt;y.pla;</span><br><span class="line">				//cout&lt;&lt;x.pla&lt;&lt;&quot; before &quot;&lt;&lt;y.pla&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				return x.pla&gt;y.pla;</span><br><span class="line">				//cout&lt;&lt;x.pla&lt;&lt;&quot; after &quot;&lt;&lt;y.pla&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return xx&gt;yy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ab(xx-tmp)&lt;ab(yy-tmp);</span><br><span class="line">&#125;</span><br><span class="line">int cmp2(E x,E y)&#123;</span><br><span class="line">	return x.pla&lt;y.pla;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	io_opt;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		e[i+1].c=s[i];</span><br><span class="line">		e[i+1].pla=i+1;</span><br><span class="line">	&#125;</span><br><span class="line">	int cmn;</span><br><span class="line">	for(int i=0;i&lt;=9;i++)&#123;</span><br><span class="line">		cmn=0;</span><br><span class="line">		cpy(cur,e);</span><br><span class="line">		tmp=i;</span><br><span class="line">		sort(cur+1,cur+1+n,cmp);</span><br><span class="line">		for(int j=1;j&lt;=k;j++)&#123;</span><br><span class="line">			cmn+=ab(cur[j].c-&#x27;0&#x27;-i);</span><br><span class="line">			cur[j].c=&#x27;0&#x27;+i;</span><br><span class="line">		&#125;</span><br><span class="line">		/*if(i==2)&#123;</span><br><span class="line">			for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">				cout&lt;&lt;cur[j].pla&lt;&lt;&#x27; &#x27;;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;*/</span><br><span class="line">		sort(cur+1,cur+1+n,cmp2);</span><br><span class="line">		if(cmn&lt;mn||cmn==mn&amp;&amp;!Ecmp(cur,ans))&#123;</span><br><span class="line">			mn=cmn;</span><br><span class="line">			for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">				ans[j]=cur[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;mn&lt;&lt;endl;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;ans[i].c;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1639 绑鞋带</title>
    <url>/2019/10/12/51Nod1639%20%E7%BB%91%E9%9E%8B%E5%B8%A6/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>有n根鞋带混在一起，现在重复n次以下操作：随机抽出两个鞋带头，把它们绑在一起。可以想象，这n次之后將不再有单独的鞋带头，n条鞋带系成了一些环。那么有多大概率刚好所有这些鞋带只形成了一个环？</p>
<h2 id="solution">Solution</h2>
<p>f(n)可以转化为f(n-1)。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line"></span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define fo(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define fo0(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">const ll mod = 998244353;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line">db fab(db x) &#123;</span><br><span class="line">    return x &gt; 0 ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line">int n;</span><br><span class="line">double a[1020]=&#123;0,1&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=a[i-1]*(2*i-2)/(2*i-1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%.6f\n&quot;,a[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1640 天气晴朗的魔法</title>
    <url>/2019/10/29/51Nod1640%20%E5%A4%A9%E6%B0%94%E6%99%B4%E6%9C%97%E7%9A%84%E9%AD%94%E6%B3%95/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>51nod魔法学校近日开展了主题为“天气晴朗”的魔法交流活动。 N名魔法师按阵法站好，之后选取N - 1条魔法链将所有魔法师的魔力连接起来，形成一个魔法阵。 魔法链是做法成功与否的关键。每一条魔法链都有一个魔力值V，魔法最终的效果取决于阵中所有魔法链的魔力值的和。 由于逆天改命的魔法过于暴力，所以我们要求阵中的魔法链的魔力值最大值尽可能的小，与此同时，魔力值之和要尽可能的大。 现在给定魔法师人数N，魔法链数目M。求此魔法阵的最大效果。</p>
<h2 id="solution">Solution</h2>
<p>最小生成树求最大边最小值，然后求最小生成树。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">ll n,m;</span><br><span class="line">ll f[100020];</span><br><span class="line">ll f2[100020];</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	ll u,v,w;</span><br><span class="line">&#125;e[200020]; </span><br><span class="line">inline int cmp(Edge a,Edge b)&#123;</span><br><span class="line">	return a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">inline int cmp2(Edge a,Edge b)&#123;</span><br><span class="line">	return a.w&gt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">inline ll find(ll x)&#123;</span><br><span class="line">	return f[x]==0?x:f[x]=find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">inline ll find2(ll x)&#123;</span><br><span class="line">	return f2[x]==0?x:f2[x]=find2(f2[x]);</span><br><span class="line">&#125;</span><br><span class="line">inline void read(ll &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">	x=0;ll f=0;char ch=getchar();</span><br><span class="line">	while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;f|=(ch==&#x27;-&#x27;);ch=getchar();&#125;</span><br><span class="line">	while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125;</span><br><span class="line">	x=f?-x:x;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	read(n);read(m);</span><br><span class="line">	ll x,y,z;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		//scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		read(x);</span><br><span class="line">		read(y);read(z);</span><br><span class="line">		e[i]=(Edge)&#123;x,y,z&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(e+1,e+1+m,cmp);</span><br><span class="line">	ll cnt=0,sum=0,mx=0;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		ll x=find(e[i].u),y=find(e[i].v);</span><br><span class="line">		if(x!=y)&#123;</span><br><span class="line">			f[x]=y;</span><br><span class="line">			cnt++;</span><br><span class="line">			//sum+=e[i].w;</span><br><span class="line">			mx=max(mx,e[i].w);</span><br><span class="line">		&#125;</span><br><span class="line">		if(cnt==n-1)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=0;</span><br><span class="line">	sort(e+1,e+1+m,cmp2);</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		ll x=find2(e[i].u),y=find2(e[i].v);</span><br><span class="line">		if(x!=y&amp;&amp;e[i].w&lt;=mx)&#123;</span><br><span class="line">			f2[x]=y;</span><br><span class="line">			cnt++;</span><br><span class="line">			sum+=e[i].w;</span><br><span class="line">			//mx=max(mx,e[i].w);</span><br><span class="line">		&#125;</span><br><span class="line">		if(cnt==n-1)&#123;</span><br><span class="line">			//cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">			printf(&quot;%lld\n&quot;,sum);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1740 蜂巢迷宫</title>
    <url>/2019/07/24/51Nod1740%20%E8%9C%82%E5%B7%A2%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<p>##题目 <img src="https://img2018.cnblogs.com/blog/1575943/201907/1575943-20190724113104452-1683001528.png" /></p>
<p>有一个无限大的蜂巢迷宫，为了方便表示每一个六边形格子，现在把座标引入到这个迷宫中，如上图年示。</p>
<p>艾瑞特在这个迷宫中街，刚开始他在(0,0)的位置，按照下图所示的路线在这个迷宫中行走。 <img src="https://img2018.cnblogs.com/blog/1575943/201907/1575943-20190724113110406-1210737310.png" /></p>
<p>走了n步以后，他想知道自己在哪个位置了。</p>
<p>##思路 走1-6步1层，7-18步2层，二分查找层数，在最后一层6个if走6边</p>
<p>##代码 #include&lt;bits/stdc++.h&gt; #define ll long long #define db double using namespace std; ll n; int main(){ cin&gt;&gt;n; if(n==0){ cout&lt;&lt;&quot;0 0&quot;; return 0; } ll l=1,r=1e9,mid,lev; while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(3<em>mid</em>(mid-1)&lt;n){ l=mid+1; lev=mid; } else r=mid-1; } //cout&lt;&lt;lev&lt;&lt;endl; ll cx=-1+2<em>lev,cy=2; n-=3</em>lev<em>(lev-1);n--; if(n&lt;=lev-1){ cx-=n,cy+=2</em>n; cout&lt;&lt;cx&lt;&lt;' '&lt;&lt;cy&lt;&lt;endl; return 0; } n-=(lev-1); cx-=(lev-1),cy+=2<em>(lev-1); if(n&lt;=lev){ cx-=2</em>n; cout&lt;&lt;cx&lt;&lt;' '&lt;&lt;cy&lt;&lt;endl; return 0; } n-=lev; cx-=lev<em>2; if(n&lt;=lev){ cx-=n,cy-=2</em>n; cout&lt;&lt;cx&lt;&lt;' '&lt;&lt;cy&lt;&lt;endl; return 0; } n-=lev; cx-=lev,cy-=2<em>lev; if(n&lt;=lev){ cx+=n,cy-=2</em>n; cout&lt;&lt;cx&lt;&lt;' '&lt;&lt;cy&lt;&lt;endl; return 0; } n-=lev; cx+=lev,cy-=2<em>lev; if(n&lt;=lev){ cx+=2</em>n; cout&lt;&lt;cx&lt;&lt;' '&lt;&lt;cy&lt;&lt;endl; return 0; } n-=lev; cx+=2<em>lev; if(n&lt;=lev){ cx+=n,cy+=2</em>n; cout&lt;&lt;cx&lt;&lt;' '&lt;&lt;cy&lt;&lt;endl; return 0; } n-=lev; cx+=lev,cy+=2*lev; return 0; }</p>
]]></content>
  </entry>
  <entry>
    <title>51Nod1755 除数游戏</title>
    <url>/2019/10/12/51Nod1755%20%E9%99%A4%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>在除数游戏中，两人轮流行动，初始时有一个整数q，每次行动要写下一个整数，这个整数必须是最近一次出现的整数的“强除数”。所谓一个整数的“强除数”是指除了1和该整数本身以外，可以整除该整数的整数。</p>
<p>当游戏的某一方找不出符合以上条件的整数时，该方取得胜利，游戏结束。</p>
<p>假设游戏双方都采取最好的策略，给出初始数字。计算第一个写数字的人赢，还是第二个写数字的人赢。</p>
<p>样例解释：</p>
<p>在样例一中，数字6的“强除数”是2和3。不管是写哪个数字，下一个人都赢了。 在样例二中，6是30的一个“强除数”。写下6后，接下来的过程同上。</p>
<h2 id="solution">Solution</h2>
<p>分解，1个因数1赢，2个2赢，再往上1写到两个，1赢。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">ll n,x;</span><br><span class="line">int s;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//prime();</span><br><span class="line">	scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">	x=n;</span><br><span class="line">	for(ll i=2;i*i&lt;=x;i++)&#123;</span><br><span class="line">		while(n%i==0)&#123;</span><br><span class="line">			n/=i;</span><br><span class="line">			s++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(s&gt;=3) break;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1) s++;</span><br><span class="line">	if(s==2)&#123;</span><br><span class="line">		printf(&quot;2\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;1\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1774 多重排序</title>
    <url>/2019/10/23/51Nod1774%20%E5%A4%9A%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>有一个数组a，长度为n，下标从1开始。现在要对a进行m次排序，每一次排序给定两个参数t[i]，r[i]表示要对数组的前r[i]个元素进行排序，如果t[i]＝1则按照非降序排序，t[i]=2则按照非升序排序。</p>
<p>请输出经过m次排序之后的数组a。</p>
<p>样例解释：</p>
<p>第一个样例中，初始序列为：1 2 3。经过第一次排序之后变成了：2 1 3。</p>
<p>第二个样例中，初始序列为：1 2 4 3。经过第一次排序之后变成了：4 2 1 3。经过第二次排序之后变成了：2 4 1 3。</p>
<h2 id="solution">Solution</h2>
<p>搞一个r单调递减的栈，从最大的r向前赋值，t=1，赋最大的值，否则赋最小的值。</p>
<p>搞stdio.h居然效率最高，欢迎吊打QAQ</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">//#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int a[200020],tmp[200020];</span><br><span class="line">struct E&#123;</span><br><span class="line">    int t,r;</span><br><span class="line">&#125;e[200020];</span><br><span class="line">E x;</span><br><span class="line">int top=0,head,tail;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x.t,&amp;x.r);</span><br><span class="line">        if(top&amp;&amp;x.r&gt;=e[top].r)&#123;</span><br><span class="line">            while(top&gt;0&amp;&amp;x.r&gt;=e[top].r)&#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e[++top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    head=1,tail=e[1].r;</span><br><span class="line">    for(int i=1;i&lt;=e[1].r;i++)&#123;</span><br><span class="line">        tmp[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(tmp+1,tmp+1+tail);</span><br><span class="line">    e[top+1].r=0;</span><br><span class="line">    for(int i=1;i&lt;=top;i++)&#123;</span><br><span class="line">        if(e[i].t==1)&#123;</span><br><span class="line">            for(int j=e[i].r;j&gt;e[i+1].r;j--)&#123;</span><br><span class="line">                a[j]=tmp[tail];</span><br><span class="line">                tail--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int j=e[i].r;j&gt;e[i+1].r;j--)&#123;</span><br><span class="line">                a[j]=tmp[head];</span><br><span class="line">                head++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod1785 数据流中的算法</title>
    <url>/2019/10/12/51Nod1785%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>51nod近日上线了用户满意度检测工具，使用高级人工智能算法，通过用户访问时间、鼠标轨迹等特征计算用户对于网站的满意程度。</p>
<p>现有的统计工具只能统计某一个窗口中，用户的满意程度的均值。夹克老爷想让你为统计工具添加一个新feature，即在统计均值的同时，计算窗口中满意程度的标准差和中位数（均值需要向下取整）。</p>
<h2 id="solution">Solution</h2>
<p>方差转化为均值相减，均值维护，中位数multiset维护每次找。</p>
<p>还有双堆维护中位数，QAQ。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define rep(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define rev(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">const ll mod = 998244353;</span><br><span class="line">const int N = 1e4 + 10;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">int n,k;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int p;</span><br><span class="line">&#125;e[1000020];</span><br><span class="line">int head=1,tail=0;</span><br><span class="line">int x,val;</span><br><span class="line">db ans;</span><br><span class="line">std::multiset&lt;int&gt;q;</span><br><span class="line">int sum=0,sum2=0;</span><br><span class="line">bool fg=false;</span><br><span class="line">int cnt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        if(x==1)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;val);</span><br><span class="line">            e[++tail].a=val;</span><br><span class="line">            e[tail].p=i;</span><br><span class="line">            sum+=val;</span><br><span class="line">            sum2+=val*val;</span><br><span class="line">            q.insert(val);</span><br><span class="line">            //cout&lt;&lt;*q.begin()&lt;&lt;endl;</span><br><span class="line">            if(tail-head+1==k+1)&#123;</span><br><span class="line">                q.erase(q.lower_bound(e[head].a));</span><br><span class="line">                sum-=e[head].a;</span><br><span class="line">                sum2-=e[head].a*e[head].a;</span><br><span class="line">                head++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt=tail-head+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(x==2)&#123;</span><br><span class="line">            ans=sum/cnt;</span><br><span class="line">            printf(&quot;%.2f\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(x==3)&#123;</span><br><span class="line">            ans=sum2/(ld)cnt-(sum/(ld)cnt)*(sum/(ld)cnt);</span><br><span class="line">            printf(&quot;%.2f\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            auto tmp=q.begin();</span><br><span class="line">            //cout&lt;&lt;&quot;!!&quot;&lt;&lt;*tmp&lt;&lt;endl;</span><br><span class="line">            if(cnt%2)&#123;</span><br><span class="line">                for(int i=1;i&lt;=cnt/2;i++)&#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;%.2f\n&quot;,(db)*tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                for(int i=1;i&lt;=cnt/2-1;i++)&#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                val=*tmp;</span><br><span class="line">                tmp++;</span><br><span class="line">                val+=*tmp;</span><br><span class="line">                printf(&quot;%.2f\n&quot;,(db)val/2.0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2201 做任务一</title>
    <url>/2019/10/12/51Nod2201%20%E5%81%9A%E4%BB%BB%E5%8A%A1%E4%B8%80/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>B君和m个人一起，要完成n个任务，在这个题中，m个人会看着这B君，自己什么都不做。</p>
<p>第i个任务有一个开始时间s[i]和结束时间e[i]（保证s[i]&lt;=e[i]），一个人完成两个任务的时间区间，不能有交集，但是可以首尾相连。（参考样例）</p>
<p>换句话说，如果一个人依次完成了(s[1], e[1]) (s[2], e[2]) (s[3], e[3])这3个任务，那么这3个任务需要满足s[1]&lt;=e[1]&lt;=s[2]&lt;=e[2]&lt;=s[3]&lt;=e[3]。</p>
<p>同一个任务只能完成一次，并且中间不能换人。</p>
<p>问B君一个人最多可以完成多少个任务。</p>
<p>(单组 n &lt;= 100000)</p>
<p>(所有 n 求和 &lt;= 200000)</p>
<p>(开始时间和结束时间，都是非负整数，且在int范围内。)</p>
<p>(开始时间 &lt;= 结束时间，如果等于的话，意味着这个任务可以瞬间被做完，但是不能没有人做)</p>
<h2 id="solution">Solution</h2>
<p>经典贪心，结束时间排序。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line"></span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define fo(d, s, t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define fo0(d, s, t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">const ll mod = 998244353;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int data = 0;</span><br><span class="line">    char ch = 0;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) ch = getchar();</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) data = data * 10 + ch - &#x27;0&#x27;, ch = getchar();</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">db fab(db x) &#123;</span><br><span class="line">    return x &gt; 0 ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,T;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int s,t;</span><br><span class="line">&#125;e[100020];</span><br><span class="line">int cmp(E x,E y)&#123;</span><br><span class="line">    if(x.t==y.t) return x.s&lt;y.s;</span><br><span class="line">    return x.t&lt;y.t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        fo(i,1,n)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;e[i].s,&amp;e[i].t);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(e+1,e+1+n,cmp);</span><br><span class="line">        int las=0,ans=0;</span><br><span class="line">        fo(i,1,n)&#123;</span><br><span class="line">            if(e[i].s&gt;=las)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                las=e[i].t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2386 分则能成</title>
    <url>/2020/01/22/51Nod2386%20%E5%88%86%E5%88%99%E8%83%BD%E6%88%90/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>牛牛刚开始有一个正整数n。 每次操作牛牛可以选择一个自己有的数字x，把x分为两正整数y和z，需满足x=y+z，然后获得y*z的收益。 （当然，在这个过程中，牛牛会失去x这个数字，并且获得y和z这2个数字。）</p>
<p>牛牛一共可以分k次，牛牛希望最大化这k次的收益之和。 因为分割的结果y和z是正整数，所以选择的x必须&gt;=2。</p>
<p>对于100%的数据，1 &lt;= k &lt; n &lt;= 10^9 对于40%的数据，1 &lt;= k &lt; n &lt;= 10 对于70%的数据，1 &lt;= k &lt; n &lt;= 100</p>
<h2 id="solution">Solution</h2>
<p>问题等价于把n拆分成k+1份，然后我们设为a1，a2，...，ak+1，发现最后答案为两两相乘，n<sup>2=(a1+a2+a3...+ak+1)</sup>2=ans+2sum(ai^2)，求ans最大即为求平方和最小，可以假设2x=c，然后用两个x和(x-1)、(x+1)平方和相减，发现前者始终是最小的，于是转化为接近分组。（具体数学上好像有相关的，不过没带回书也不知道是啥）</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll n,k;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	k++;</span><br><span class="line">	int d=n/k;</span><br><span class="line">	ll sum=(k-n%k)*d*d+n%k*(d+1)*(d+1);</span><br><span class="line">	ll ans=(n*n-sum)/2;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2206 低买高卖</title>
    <url>/2019/10/03/51Nod2206%20%E4%BD%8E%E4%B9%B0%E9%AB%98%E5%8D%96/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>考虑股票市场，一共有n天。 对于第i天，B君知道股票的价格是每单位a[i]元 在每一天，B君可以选择买入一个单位的股票，卖出一个单位的股票，或者什么都不做。 刚开始B君有无穷多的钱，但是没有任何股票。 问n天之后B君最多可以赚多少钱。 (1 &lt;= n &lt;= 200000) (1 &lt;= a[i] &lt;= 10000)</p>
<h2 id="solution">Solution</h2>
<p>一开始思路是如果四天递增，买卖买卖肯定不如买买卖卖，就从最高和最低贪心，但发现绕不过时间，就去翻题解了。</p>
<p>题解都是通过顺序来解决时间问题的。</p>
<p>变形比如只能拥有一支股票，每天可以买卖各一次，或者只能买或卖一次。做法2参考博客前面说的是哪种看不明白。</p>
<p>做法1：</p>
<p><a href="https://blog.csdn.net/xumingyang0/article/details/85147460">51nod 2206 低买高卖&amp;codeforces867E Buy Low Sell High</a></p>
<p>这个思路比较简单，如果堆空或者当前元素比堆顶元素小，就进堆，否则加入答案，弹出堆顶，进堆两次。</p>
<p>进堆两次是因为，如果轮到它做堆顶，再来一个最大的，可以理解为前面那次操作没有用它，正好还有一个它在堆里。如果又轮到它，就相当于又选了它。</p>
<p>那为什么没有第三次、第四次进堆呢？</p>
<p>可以看出这个数可能做一个中间量，如果第一次做完中间量以后再次成为堆中最小的，那么就必定买入，没有作为中间量的机会。</p>
<p>新来的更小的数或者第一个数就没有做中间量的机会。</p>
<p>做法2：</p>
<p><a href="https://blog.csdn.net/wentong_Xu/article/details/96970769">【51Nod】2206 低买高卖</a></p>
<p>直接加入两次，计算答案，弹出一次。</p>
<p>这样一看似乎会有答案增量为负的情形，但实际不会，因为如果当前加入的是比答案小的数，它会减掉自己，增量为0，然后弹出自己，第一个数一样，其余情况转化到做法1。</p>
<h3 id="第一个用iostream快第二个改成vector快可能是iostream对于empty有优化">第一个用iostream快，第二个改成vector快，可能是iostream对于empty有优化？</h3>
<h2 id="code1">Code1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">long long ans;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	int x;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">		if(q.empty()||x&lt;=q.top())&#123;</span><br><span class="line">			q.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			ans+=x-q.top();</span><br><span class="line">			q.pop();</span><br><span class="line">			q.push(x);</span><br><span class="line">			q.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%I64d\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code2">Code2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">long long ans;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	int x;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">		q.push(x);</span><br><span class="line">		q.push(x);</span><br><span class="line">		ans+=x-q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%I64d\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2488 矩形并的面积</title>
    <url>/2019/09/08/51Nod2488%20%E7%9F%A9%E5%BD%A2%E5%B9%B6%E7%9A%84%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>在二维平面上，给定两个矩形，满足矩形的每条边分别和坐标轴平行，求这个两个矩形的并的面积。即它们重叠在一起之后的总的面积。</p>
<h2 id="solution">Solution</h2>
<p>这方法真神奇。。。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">#define ll long long</span><br><span class="line">const int MAXN=100020;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Point&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p[10];</span><br><span class="line">int iabs(int s)&#123;</span><br><span class="line">    return s&gt;0?s:-s;</span><br><span class="line">&#125;</span><br><span class="line">bool tog(Point p1,Point p2,Point p3,Point p4)&#123;</span><br><span class="line">    return (p1.x&lt;=p3.x&amp;&amp;p1.y&lt;=p3.y&amp;&amp;p2.x&gt;=p4.x&amp;&amp;p2.y&gt;=p4.y)||(p1.x&gt;=p3.x&amp;&amp;p1.y&gt;=p3.y&amp;&amp;p2.x&lt;=p4.x&amp;&amp;p2.y&lt;=p4.y);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    for(int i=1;i&lt;=4;i++)&#123;</span><br><span class="line">        cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    int s1=(p[2].x-p[1].x)*(p[2].y-p[1].y),s2=(p[4].x-p[3].x)*(p[4].y-p[3].y);</span><br><span class="line">    if(tog(p[1],p[2],p[3],p[4]))&#123;</span><br><span class="line">        cout&lt;&lt;max(s1,s2);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=s1;s+=s2;</span><br><span class="line">    int a1=max(p[1].x,p[1].y);</span><br><span class="line">    int b1=max(p[1].y,p[3].y);</span><br><span class="line">    int a2=min(p[2].x,p[4].x);</span><br><span class="line">    int b2=min(p[2].y,p[4].y);</span><br><span class="line">    if(a1&lt;a2&amp;&amp;b1&lt;b2)&#123;</span><br><span class="line">        cout&lt;&lt;s-(a2-a1)*(b2-b1)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2489 小b和灯泡</title>
    <url>/2019/09/07/51Nod2489%20%E5%B0%8Fb%E5%92%8C%E7%81%AF%E6%B3%A1/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小b有n个关闭的灯泡，编号为1...n。</p>
<p>小b会进行n轮操作，第i轮她会将编号为i的倍数的灯泡的开关状态取反，即开变成关，关变成开。</p>
<p>求n轮操作后，有多少灯泡是亮着的。</p>
<h2 id="solution">Solution</h2>
<p>对一个数的因数找规律，发现只有平方数才会出现奇数的因数，因此答案为(int)srqt(n)</p>
]]></content>
  </entry>
  <entry>
    <title>51Nod2499 不降的数字</title>
    <url>/2019/10/05/51Nod2499%20%E4%B8%8D%E9%99%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小b有一个非负整数N，她想请你找出 ≤𝑁 的最大整数x，满足x各个位数上的数字是不降的。也就是说，设x的十进制表示为 𝑎1,𝑎2,…,𝑎𝑚，则对于任意 1≤𝑖&lt;𝑚，𝑎𝑖≤𝑎𝑖+1。</p>
<h2 id="solution">Solution</h2>
<p>从后向前找，每次不满足不降，前面的数就减一，这时候后面的所有数都可以变成9。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef __int128 lll;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">int n,cnt,a[20];</span><br><span class="line">int main()&#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int bf=n;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        a[++cnt]=n%10;</span><br><span class="line">        n/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i&lt;=cnt;i++)&#123;</span><br><span class="line">        if(a[i]&gt;a[i-1])&#123;</span><br><span class="line">            a[i]--;</span><br><span class="line">            for(int j=i-1;j&gt;=1;j--)&#123;</span><br><span class="line">                a[j]=9;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!a[cnt]) cnt--;</span><br><span class="line">    for(int i=cnt;i&gt;=1;i--)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2493 二进制距离之和</title>
    <url>/2019/10/12/51Nod2493%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小b有一个数组a，她想知道a中任意两个数之间二进制距离的总和。</p>
<p>两个整数的二进制距离指的是这两个数字的二进制数对应位不同的数量。</p>
<p>样例解释：</p>
<blockquote>
<blockquote>
<p>在二进制表示中，4表示为0100，14表示为1110，2表示为0010。 4和14的距离为2，因为0100和1110只有右数第2,4位不同。其他同理。 所以答案为： Distance(4, 14) + Distance(4, 2) + Distance(14, 2) = 2 + 2 + 2 = 6.</p>
</blockquote>
</blockquote>
<h2 id="solution">Solution</h2>
<p>对于每一位，假设有x个1，那么这一位的距离是x*(n-x)，相加即可。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n,x,sum[120];</span><br><span class="line">ll ans=0;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">		for(int j=0;j&lt;=30;j++)&#123;</span><br><span class="line">			if(x&amp;(1&lt;&lt;j))&#123;</span><br><span class="line">				sum[j]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;=30;i++)&#123;</span><br><span class="line">		ans+=sum[i]*(n-sum[i]); </span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2518 和为S</title>
    <url>/2019/09/08/51Nod2518%20%E5%92%8C%E4%B8%BAS/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小b有一个01序列A，她想知道A有多少个非空连续子序列和为S。</p>
<p>你能帮帮她吗？</p>
<h2 id="solution">Solution</h2>
<p>暴力，可以搞一下剪枝。</p>
<p>另外也可以枚举位置，建一个mp[num]，记录枚举到i位置时，前面的每个前缀和num出现过几次，每次把当前前缀和减去m在之前出现的数量加入答案即可。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int n,s,ans;</span><br><span class="line">int a[30020];</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i]+=a[i-1];</span><br><span class="line">        //cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    int cs=(s==0||s==1)?0:s-1;</span><br><span class="line">    for(int i=1;i&lt;=n-cs;i++)&#123;</span><br><span class="line">        for(int j=i+cs;j&lt;=n;j++)&#123;</span><br><span class="line">            //cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">            if(a[j]-a[i-1]&gt;s) break;</span><br><span class="line">            if(a[j]-a[i-1]==s) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2519 小b浇花</title>
    <url>/2019/10/12/51Nod2519%20%E5%B0%8Fb%E6%B5%87%E8%8A%B1/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小b养了n盆花，第i盆花高度为A[i]。</p>
<p>小b每天可以给某一盆花浇水，这样这盆花就会长高一单位。</p>
<p>小b希望每盆花都是独一无二的，也就是不存在两盆花高度相等。</p>
<p>求小b最少要浇几天水。</p>
<h2 id="solution">Solution</h2>
<p>冲着一个浇水和把一个浇到一个高度，再浇这个高度的一盆是一样的。</p>
<p>因此如果𝑎[𝑖+1]&lt;=𝑎[𝑖]，则让𝑎[𝑖+1]=𝑎[𝑖]+1。</p>
<p>由于a[i]只有40000，可以每个高度做标记然后找。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef __int128 lll;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">int n,ans,cnt;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int a,pla;</span><br><span class="line">&#125;;</span><br><span class="line">E h[40020];</span><br><span class="line">E b[40020];</span><br><span class="line">int cmp1(E x,E y)&#123;</span><br><span class="line">    return x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line">int cmp2(E x,E y)&#123;</span><br><span class="line">    return x.pla&lt;y.pla;</span><br><span class="line">&#125;</span><br><span class="line">bool f[80020];</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;h[i].a;</span><br><span class="line">        f[h[i].a]=true;</span><br><span class="line">        h[i].pla=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h+1,h+1+n,cmp1);</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(h[i].a&lt;=h[i-1].a)&#123;</span><br><span class="line">            ans+=h[i-1].a+1-h[i].a;</span><br><span class="line">            h[i].a=h[i-1].a+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2522 和为K的倍数</title>
    <url>/2019/10/03/51Nod2522%20%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%80%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小b喜欢和为K的倍数的序列。</p>
<p>现在有一个长度为n的序列A，请问A有多少个非空连续子序列是小b喜欢的。</p>
<h2 id="solution">Solution</h2>
<p>求一个前缀和，mod k，如果数组i和j(i&lt;=j)位置相等，则从i+1到j位置的序列和为k的倍数，任选两个即可，k不大，用数组记录，注意0的时候包含本身。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define io_opt std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">int n,k,a[30020],ans;</span><br><span class="line">int sum[30020];</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		a[i]+=a[i-1];</span><br><span class="line">		a[i]=(a[i]+k*10000)%k;</span><br><span class="line">		sum[a[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=sum[0];</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">		if(sum[i]) ans+=(sum[i]*(sum[i]-1))/2;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2540 平分</title>
    <url>/2019/10/05/51Nod2540%20%E5%B9%B3%E5%88%86/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>考虑足球比分系统，一场足球比赛从开始到结束的过程中，摄像机随机拍摄了𝑛张比分信息，问你本场比赛最多出现了几次平分。</p>
<p>例如：3个比分信息为：</p>
<p>2 0 3 1 3 4</p>
<p>最终比分为3:4，所以最多只可能出现最初的0:0以及3:3这2次平分。如果只有1张3:4，那么最多可能有0:0 1:1 2:2 3:3共4次平分。</p>
<h2 id="solution">Solution</h2>
<p>添加一个0：0，相邻的A队分区间和B队分区间取交集，map去重，注意cur可能为0。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef __int128 lll;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">int n,ans;</span><br><span class="line">map&lt;int,bool&gt;mp;</span><br><span class="line">int a[10020],b[10020];</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int x1,x2,y1,y2,l,r;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        x1=a[i-1],x2=a[i];</span><br><span class="line">        y1=b[i-1],y2=b[i];</span><br><span class="line">        l=max(x1,y1),r=min(x2,y2);</span><br><span class="line">        int cur=max(r-l+1,0);</span><br><span class="line">        if(cur==1)&#123;</span><br><span class="line">            if(!mp[l])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                mp[l]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(cur&gt;=2)&#123;</span><br><span class="line">            if(mp[l]) cur--;</span><br><span class="line">            if(mp[r]) cur--;</span><br><span class="line">            ans+=cur;</span><br><span class="line">            mp[l]=true;</span><br><span class="line">            mp[r]=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2526 最大异或和</title>
    <url>/2019/10/12/51Nod2526%20%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给定𝑛个数𝑥1…𝑥𝑛，请你选择n个数𝑝1…𝑝𝑛，使得𝑝1&lt;=𝑥1,𝑝2&lt;=𝑥2......，并且𝑝1 𝑥𝑜𝑟 𝑝2 𝑥𝑜𝑟 𝑝3 … 𝑝𝑛的值尽量大。问这个最大的异或和是多少。</p>
<p>𝑛≤100 , 0≤𝑥𝑖≤1e9</p>
<h2 id="solution">Solution</h2>
<p>拆成二进制位，由于最小可以为0，每一位保持一个为1就可以，多的可以变成下面所有1。</p>
<p>从最高位开始扫，这一位出现1个1，ans这一位就为1，出现俩，后面所有的都为1。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define fo(d,s,t) for(int d=s;d&lt;=t;d++)</span><br><span class="line">#define fo0(d,s,t) for(int d=s;d&gt;=t;d--)</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line"></span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">int n,a[120];</span><br><span class="line">int f[120][35];</span><br><span class="line">int ans[35];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    fo(i,1,n)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fo(i,1,n)&#123;</span><br><span class="line">        fo0(j,32,1)&#123;</span><br><span class="line">            if(a[i]&amp;1)&#123;</span><br><span class="line">                f[i][j]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i]&gt;&gt;=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fo(i,1,32)&#123;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        fo(j,1,n)&#123;</span><br><span class="line">            if(f[j][i])&#123;</span><br><span class="line">                ans[i]=1;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt&gt;=2)&#123;</span><br><span class="line">            fo(j,i+1,32)&#123;</span><br><span class="line">                ans[j]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int anss=0;</span><br><span class="line">    fo(i,1,32)&#123;</span><br><span class="line">        anss&lt;&lt;=1;</span><br><span class="line">        anss+=ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,anss);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2594 括号之价</title>
    <url>/2019/10/04/51Nod2594%20%E6%8B%AC%E5%8F%B7%E4%B9%8B%E4%BB%B7/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小Y上数据结构课的时候摸鱼，听到老师在讲用栈做括号匹配，于是乎边随意写了一个合法的括号序列。但是光是写括号太无聊了，他现在想知道这个括号序列的价值。他是这样定义一个括号序列的价值的：</p>
<p>1、一对括号价值一分（比如&quot;()&quot;得一分）</p>
<p>2、两个合法的括号序列的拼接而成的括号序列的价值是他们的价值的和（比如&quot;()()&quot;价值为1+1=2）</p>
<p>3、嵌套的括号的序列的价值是，所嵌套的括号序列的价值的翻倍（比如&quot;((()))&quot;价值为1<em>2</em>2=4）</p>
<p>下课了，qz看到小Y写的括号序列，他一眼就推测出了规则并得到了括号序列的价值。那么问题来了，小Y写下的括号序列的价值是多少呢？</p>
<h2 id="solution">Solution</h2>
<p>赋值深度，然后找最近的深度dfs。</p>
<p>题解是把价值也放进去，每次碰到右括号就全加起来*2。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mod 998244353LL</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">#define ll long long</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">ll lowspeed(ll a,ll b,ll p)&#123;ll cur=a,ans=0;while(b)&#123;if(b&amp;1) ans=(ans+cur)%p;cur=(cur+cur)%p;b&gt;&gt;=1;&#125;return ans%p;&#125;</span><br><span class="line">ll speed(ll a,ll b,ll p)&#123;ll cur=a,ans=1;while(b)&#123;if(b&amp;1) ans=lowspeed(ans,cur,p)%p;cur=lowspeed(cur,cur,p)%p;b&gt;&gt;=1;&#125;return ans%p;&#125;</span><br><span class="line">string s;</span><br><span class="line">int a[120];</span><br><span class="line">int dfs(int l,int r,int val)&#123;</span><br><span class="line">    if(r==l+1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum=0,a1=0,a2=0;</span><br><span class="line">    for(int i=l+1;i&lt;r;i++)&#123;</span><br><span class="line">        if(a[i]==val+1)&#123;</span><br><span class="line">            if(a1==0)&#123;</span><br><span class="line">                a1=i;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                a2=i;</span><br><span class="line">                sum+=dfs(a1,a2,val+1);</span><br><span class="line">                a1=a2=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum*2;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    int dep=0;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;)&#123;</span><br><span class="line">            dep++;</span><br><span class="line">            a[i]=dep;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            a[i]=dep;</span><br><span class="line">            dep--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0,x1=-1,x2=-1;</span><br><span class="line">    for(int i=0;i&lt;=s.size();i++)&#123;</span><br><span class="line">        if(a[i]==1)&#123;</span><br><span class="line">            if(x1==-1)&#123;</span><br><span class="line">                x1=i;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                x2=i;</span><br><span class="line">                ans+=dfs(x1,x2,1);</span><br><span class="line"></span><br><span class="line">                x1=x2=-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2542 咖啡和作业</title>
    <url>/2019/10/29/51Nod2542%20%E5%92%96%E5%95%A1%E5%92%8C%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>你要完成一个𝑚页的作业，手里有𝑛杯咖啡，每一杯咖啡有一个咖啡因强度值𝑎𝑖，能支撑你写𝑎𝑖页作业。每一天你会选择一些咖啡喝掉，对于当天喝的第i杯咖啡，咖啡因的强度会减弱𝑖−1单位，减到0就不再减小。问你最少经过几天能完成作业。</p>
<h2 id="solution">Solution</h2>
<p>贪心，二分天数，然后最大的开始往每天填。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,sum;</span><br><span class="line">int a[120];</span><br><span class="line">int ans;</span><br><span class="line">int cnt[120];</span><br><span class="line">int sm;</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    memset(cnt,0,sizeof(cnt));</span><br><span class="line">    sm=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int num=i%x;</span><br><span class="line">        sm+=max(a[i]-cnt[num],0);</span><br><span class="line">        //cout&lt;&lt;&#x27;!&#x27;&lt;&lt;sm&lt;&lt;endl;</span><br><span class="line">        cnt[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    return sm&gt;=m;</span><br><span class="line">&#125;</span><br><span class="line">int cmp(int x,int y)&#123;</span><br><span class="line">    return x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    n=rd();m=rd();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=rd();</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+1+n,cmp);</span><br><span class="line">    if(sum&lt;m)&#123;</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int l=1,r=n,mid;</span><br><span class="line">    //cout&lt;&lt;check(2)&lt;&lt;endl;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)/2;</span><br><span class="line">        if(check(mid))&#123;</span><br><span class="line">            r=mid-1;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            l=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2602 树的直径</title>
    <url>/2019/10/29/51Nod2602%20%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>一棵树的直径就是这棵树上存在的最长路径。现在有一棵n个节点的树，现在想知道这棵树的直径包含的边的个数是多少？</p>
<h2 id="solution">Solution</h2>
<p>随便找一个点，找最远的，再找新的点最远的。</p>
<p>当然我瞎搞的树状dp，子树分支最大的和次大的加起来就行。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod=998244353;</span><br><span class="line">int mo(ll a,int p)&#123;</span><br><span class="line">    return a&gt;=p?a%p:a;</span><br><span class="line">&#125;</span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line">int n,ans;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int u,v,nex;</span><br><span class="line">&#125;e[200020];</span><br><span class="line">int g[100020];</span><br><span class="line">int f[100020];</span><br><span class="line">int dfs(int x)&#123;</span><br><span class="line">    int mx1=0,mx2=0;</span><br><span class="line">    for(int i=g[x];i&gt;0;i=e[i].nex)&#123;</span><br><span class="line">        if(!f[e[i].v])&#123;</span><br><span class="line">            f[e[i].v]=1;</span><br><span class="line">            int d=dfs(e[i].v);</span><br><span class="line">            f[e[i].v]=0;</span><br><span class="line">            if(!mx1)&#123;</span><br><span class="line">                mx1=d;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(!mx2)&#123;</span><br><span class="line">                mx2=d;</span><br><span class="line">                if(mx2&gt;mx1) swap(mx1,mx2);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(d&gt;mx2) mx2=d;</span><br><span class="line">                if(mx2&gt;mx1) swap(mx1,mx2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=max(ans,mx1+mx2+1);</span><br><span class="line">    if(!mx1&amp;&amp;!mx2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return mx1+1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    n=rd();</span><br><span class="line">    int x,y;</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">        x=rd(),y=rd();</span><br><span class="line">        e[i]=(E)&#123;x,y,g[x]&#125;;g[x]=i;</span><br><span class="line">        e[i+n-1]=(E)&#123;y,x,g[y]&#125;;g[y]=i+n-1;</span><br><span class="line">    &#125;</span><br><span class="line">    f[1]=1;</span><br><span class="line">    dfs(1);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2658 最多分成多少块 V2</title>
    <url>/2019/10/05/51Nod2658%20%E6%9C%80%E5%A4%9A%E5%88%86%E6%88%90%E5%A4%9A%E5%B0%91%E5%9D%97%20V2/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>小b有个长度为n的数组a，她想将这个数组排序。</p>
<p>然而小b很懒，她觉得对整个数组排序太累了，因此她请你将a分成一些块，使得她只需要对每一块分别排序，就能将整个数组排序。</p>
<p>请问你最多能把a分成多少块。</p>
<p>保证a为0...n-1的一个排列。</p>
<p>样例解释：</p>
<p>将a分成2块或者更多块，都无法得到所需的结果。 例如，分成 [4, 3], [2, 1, 0] ，排序得到的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。</p>
<h2 id="solution">Solution</h2>
<p>题目的意思是升序排，一种麻烦的思路是每添加一个数小于i就cur+1，否则进堆，每次看能否从堆中取出，cur==i时ans+1。</p>
<p>再仔细想，只需要前面出现的最大的数和当前i相等，ans就能+1。</p>
<h2 id="code1">Code1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef __int128 lll;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">int n,x,ans,cur;</span><br><span class="line">std::priority_queue&lt;int,std::vector&lt;int&gt;,std::greater&lt;int&gt; &gt;q;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        int j=n-i-1;</span><br><span class="line">        while(!q.empty()&amp;&amp;q.top()&lt;=i)&#123;</span><br><span class="line">            q.pop();</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x&lt;=i)&#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            q.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur==i+1)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="code2">Code2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef __int128 lll;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">int n,x,ans,mx;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        mx=std::max(x,mx);</span><br><span class="line">        if(mx==i)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2671 平衡环</title>
    <url>/2019/10/29/51Nod2671%20%E5%B9%B3%E8%A1%A1%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>给定一棵𝑛个点的树，每条边有一个边权，边权只可能是4或7。你想在树上选择两个没有直接连边的点，并在这两点间加一条边权为4或7的连边。很显然，树上出现一个环，如果这个环上边权为4的边数与边权为7的边数相等，那么这个环是一个平衡环。你希望得到这样一个平衡环，请问需要连接哪两个点，并赋予什么边权。</p>
<p>如果有多种方案，输出任意一组解即可。如果无解，输出-1。</p>
<p>数据范围：1≤𝑛≤100</p>
<h2 id="solution">Solution</h2>
<p>必定是长度为3的路，一开始dfs点1留影子找，后来发现只能dfs所有点，这样就是𝑂(n^2)的了。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n,g[1020];</span><br><span class="line">struct E&#123;</span><br><span class="line">    int u,v,w,nex;</span><br><span class="line">&#125;e[1020];</span><br><span class="line">int ansu=0,ansv=0;</span><br><span class="line">int f[1020];</span><br><span class="line">void dfs(int d1,int d2,int d3,int l1,int l2)&#123;</span><br><span class="line">    if(ansu&amp;&amp;ansv) return;</span><br><span class="line">    int n4=0,n7=0;</span><br><span class="line">    if(l1==4) n4++;</span><br><span class="line">    else if(l1==7) n7++;</span><br><span class="line">    if(l2==4) n4++;</span><br><span class="line">    else if(l2==7) n7++;</span><br><span class="line">    for(int i=g[d3];i&gt;0;i=e[i].nex)&#123;</span><br><span class="line">        if(f[e[i].v]) continue;</span><br><span class="line">        if(e[i].w==4) n4++;</span><br><span class="line">        else if(e[i].w==7) n7++;</span><br><span class="line">        if(n4&amp;&amp;n7&amp;&amp;n4+n7==3)&#123;</span><br><span class="line">            ansu=1,ansv=1;</span><br><span class="line">            if(n4==2)&#123;</span><br><span class="line"></span><br><span class="line">                cout&lt;&lt;d1&lt;&lt;&#x27; &#x27;&lt;&lt;e[i].v&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;7&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cout&lt;&lt;d1&lt;&lt;&#x27; &#x27;&lt;&lt;e[i].v&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;4&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(e[i].w==4) n4--;</span><br><span class="line">        else if(e[i].w==7) n7--;</span><br><span class="line">        f[e[i].v]=1;</span><br><span class="line">        dfs(d2,d3,e[i].v,l2,e[i].w);</span><br><span class="line">        f[e[i].v]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        e[i]=(E)&#123;x,y,z,g[x]&#125;;g[x]=i;</span><br><span class="line">        e[i+n-1]=(E)&#123;y,x,z,g[y]&#125;;g[y]=i+n-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ansu=ansv=0;</span><br><span class="line">        f[i]=1;</span><br><span class="line">        dfs(0,0,i,0,0);</span><br><span class="line">        f[i]=0;</span><br><span class="line">        if((ansu&amp;&amp;ansv))&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2657 二进制数字</title>
    <url>/2019/10/05/51Nod2657%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>有多少个长度为n的二进制串，即不存在3个连续的1，也不存在3个连续的0。</p>
<p>例如n = 4，共有16个长度为4的01串，其中0000 0001 1000 1111 0111 1110，不符合要求，所以共有10个符合要求的串。</p>
<h2 id="solution">Solution</h2>
<p><a href="http://www.51nod.com/Challenge/ProblemSolution.html#problemId=2657">2657 二进制数字-题解</a></p>
<p>推荐买题解，这题解tql。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define mem(ss) memset(ss,0,sizeof(ss))</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef __int128 lll;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">inline int read()&#123;int data=0;char ch=0;while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar();while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;) data=data*10+ch-&#x27;0&#x27;,ch=getchar();return data;&#125;</span><br><span class="line">int n;</span><br><span class="line">ll a[5]=&#123;0,2,4&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    if(n&lt;=2)&#123;</span><br><span class="line">        cout&lt;&lt;a[n]&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d1=2,d2=4,cur;</span><br><span class="line">    for(int i=3;i&lt;=n;i++)&#123;</span><br><span class="line">        cur=(d1+d2)%mod;</span><br><span class="line">        d1=d2%mod;</span><br><span class="line">        d2=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cur&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2676 众里寻花</title>
    <url>/2019/11/02/51Nod2676%20%E4%BC%97%E9%87%8C%E5%AF%BB%E8%8A%B1/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>有𝑛个彩灯每个彩灯有一种颜色𝑐𝑜𝑙𝑖（彩灯从1到n标号），有𝑚根细线将它们连接在一起。你想用这些彩灯作出一朵美丽的花，进一步说你想从这𝑚根细线中保留𝑛−1根，且需要保证所有彩灯是连通在一起的。你希望这朵花五彩斑斓，因此你想要连接同颜色彩灯的细线越少越好。请问这个最小值是多少？</p>
<p>数据范围：</p>
<p>2≤𝑛≤100,1≤𝑚≤200,1≤𝑐𝑜𝑙𝑖≤𝑛</p>
<h2 id="solution">Solution</h2>
<p>连接同颜色的是1，否则为0，然后最小生成树。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod=998244353;</span><br><span class="line">int mo(ll a,int p)&#123;</span><br><span class="line">    return a&gt;=p?a%p:a;</span><br><span class="line">&#125;</span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,f[120],ans;</span><br><span class="line">int a[120];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    return f[x]==0?x:f[x]=find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int u,v,w;</span><br><span class="line">&#125;e[220];;</span><br><span class="line">int cmp(E x,E y)&#123;</span><br><span class="line">    return x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int x,y;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        if(a[x]==a[y])&#123;</span><br><span class="line">            e[i]=(E)&#123;x,y,1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            e[i]=(E)&#123;x,y,0&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e+1,e+1+m,cmp);</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        //cout&lt;&lt;e[i].w&lt;&lt;endl;</span><br><span class="line">        int u=find(e[i].u),v=find(e[i].v);</span><br><span class="line">        if(u!=v)&#123;</span><br><span class="line">            f[u]=v;</span><br><span class="line">            cnt++;</span><br><span class="line">            if(e[i].w) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt==n-1) break;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>51Nod2680 争渡</title>
    <url>/2019/10/29/51Nod2680%20%E4%BA%89%E6%B8%A1/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>人生如逆水行舟，不进则退。你一生中有𝑛个阶段，每个阶段有一个状态下限𝐿𝑖，也有一个状态上限𝑅𝑖，你想规划你的一生中各阶段的状态值，使得你的状态在𝑛个阶段中始终在变好（严格递增）。请你计算有多少种不同的人生规划。由于答案较大，只需输出答案对998244353取余的结果</p>
<p>数据范围：1≤𝑛≤200,1≤𝐿𝑖≤𝑅𝑖≤104</p>
<h2 id="solution">Solution</h2>
<p>解法请购买，这里谈一点优化。</p>
<p>反正多余的也没啥用。</p>
<p>对于下限l，如果前一个大，当前的可以修改为前一个。（升序）</p>
<p>对于上限r，如果后一个小，当前的可以修改为后一个。（降序）</p>
<p>对于每个i，求j=l[i]的值，即求前面i-1，j小于l[i]的和时，从l[i-1]开始求。</p>
<h2 id="code">Code</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef long double ld;</span><br><span class="line">typedef double db;</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">//using namespace std;</span><br><span class="line">const int mod=998244353;</span><br><span class="line">int mo(ll a,int p)&#123;</span><br><span class="line">    return a&gt;=p?a%p:a;</span><br><span class="line">&#125;</span><br><span class="line">inline int rd() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;)f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return f * x;</span><br><span class="line">&#125;</span><br><span class="line">int n,sum;</span><br><span class="line">int l[220],r[220];</span><br><span class="line">int f[220][10020];</span><br><span class="line">inline int min(int a,int b)&#123;</span><br><span class="line">    return a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //io_opt;</span><br><span class="line">    n=rd();</span><br><span class="line">    f[0][0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        l[i]=rd();</span><br><span class="line">        r[i]=rd();</span><br><span class="line">        if(l[i]&lt;l[i-1]) l[i]=l[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n;i&gt;=2;i--)&#123;</span><br><span class="line">        if(r[i]&lt;r[i-1]) r[i-1]=r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=l[i-1];j&lt;l[i];j++) f[i][l[i]]=mo(f[i-1][j]+f[i][l[i]],mod);</span><br><span class="line">        for(int j=l[i]+1;j&lt;=r[i];j++)&#123;</span><br><span class="line">            f[i][j]=mo((ll)f[i-1][j-1]+f[i][j-1],mod);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=l[n];i&lt;=r[n];i++)&#123;</span><br><span class="line">        sum=mo((ll)sum+f[n][i],mod);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Disk Tree</title>
    <url>/2019/06/23/Disk%20Tree/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>Hacker Bill has accidentally lost all the information from his workstation's hard drive and he has no backup copies of its contents. He does not regret for the loss of the files themselves, but for the very nice and convenient directory structure that he had created and cherished during years of work. Fortunately, Bill has several copies of directory listings from his hard drive. Using those listings he was able to recover full paths (like &quot;WINNT32~186&quot;) for some directories. He put all of them in a file by writing each path he has found on a separate line. Your task is to write a program that will help Bill to restore his state of the art directory structure by providing nicely formatted directory tree.</p>
<p>###输入</p>
<p>The first line of the input file contains single integer number N (1 &lt;= N &lt;= 500) that denotes a total number of distinct directory paths. Then N lines with directory paths follow. Each directory path occupies a single line and does not contain any spaces, including leading or trailing ones. No path exceeds 80 characters. Each path is listed once and consists of a number of directory names separated by a back slash (&quot;&quot;).</p>
<p>Each directory name consists of 1 to 8 uppercase letters, numbers, or the special characters from the following list: exclamation mark, number sign, dollar sign, percent sign, ampersand, apostrophe, opening and closing parenthesis, hyphen sign, commercial at, circumflex accent, underscore, grave accent, opening and closing curly bracket, and tilde (&quot;!#$%&amp;'()-@^_`{}~&quot;).</p>
<p>###输出</p>
<p>Write to the output file the formatted directory tree. Each directory name shall be listed on its own line preceded by a number of spaces that indicate its depth in the directory hierarchy. The subdirectories shall be listed in lexicographic order immediately after their parent directories preceded by one more space than their parent directory. Top level directories shall have no spaces printed before their names and shall be listed in lexicographic order. See sample below for clarification of the output format.</p>
<p>###样例输入</p>
<blockquote>
<p>7 WINNT32 GAMES WINNT HOME WIN GAMES WINNT32~186</p>
</blockquote>
<p>###样例输出 GAMES DRIVERS HOME WIN SOFT WINNT DRIVERS SYSTEM32 CERTSRV CERTCO~1 X86 CONFIG</p>
<p>####瞎搞代码，只能在学校OJ上交过，POJ上交超时 ####一开始想成文件名不重复了，正解是手动链树，多叉转二叉，添加节点的时候排序，vector瞎搞模拟有点慢，懒得改了</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
using namespace std;
int n,cnt,T;
struct E&#123;
    string s;
    int pla;
    vector&lt;int&gt;v;
&#125;;
E fir[520];
E node[20020];
int fircnt=0;
int cmp(E x,E y)&#123;
    return x.s&lt;y.s;
&#125;
int cmp1(int x,int y)&#123;
    return node[x].s&lt;node[y].s;
&#125;
void dfs(int cur,int h)&#123;
    if(cur==0) return;
    if(h==0)&#123;
        cout&lt;&lt;fir[cur].s&lt;&lt;endl;
        sort(fir[cur].v.begin(),fir[cur].v.end(),cmp1);
        for(int i=0;i&lt;fir[cur].v.size();i++)&#123;
            dfs(fir[cur].v[i],h+1);
        &#125;
    &#125;
    else&#123;
        for(int i=1;i&lt;=h;i++) printf(&quot; &quot;);
        cout&lt;&lt;node[cur].s&lt;&lt;endl;
        sort(node[cur].v.begin(),node[cur].v.end(),cmp1);
        for(int i=0;i&lt;node[cur].v.size();i++)&#123;
            dfs(node[cur].v[i],h+1);
        &#125;
    &#125;
&#125;
 
int main()&#123;
    //freopen(&quot;I.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;I.out&quot;,&quot;w&quot;,stdout);
    //cin&gt;&gt;T;
    T=1;
    while(T--)&#123;
        //for(int i=1;i&lt;=cnt;i++) a[i].clear();
        cnt=fircnt=0;
        //memset(e,0,sizeof(e));
        //memset(root,0,sizeof(root));
        //mp.clear();
        cin&gt;&gt;n;
        string s0;
        for(int i=1;i&lt;=n;i++)&#123;
            cin&gt;&gt;s0;
            int x1=-1,x2=-1;
            string tmps=&quot;&quot;;//,last=&quot;&quot;;
            int last=0,tmp,cur=0;
            for(int j=0;j&lt;s0.size();j++)&#123;
                if(x2==-1&amp;&amp;s0[j]==&#39;\\&#39;)&#123;
                    cur++;
                    x2=j;
                    tmps=s0.substr(0,j);
                    tmp=-1;
                    for(int k=1;k&lt;=fircnt;k++)&#123;
                        if(tmps==fir[k].s)&#123;
                            tmp=k;
                            break;
                        &#125;
                    &#125;
                    if(tmp==-1)&#123;
                        ++fircnt;
                        fir[fircnt]=(E)&#123;tmps,fircnt&#125;;
                        last=fircnt;
                    &#125;
                    else&#123;
                        last=fir[tmp].pla;
                    &#125;
                    //cout&lt;&lt;tmps&lt;&lt;&#39; &#39;;
                &#125;
                else if(s0[j]==&#39;\\&#39;)&#123;
                    cur++;
                    x1=x2,x2=j;
                    tmps=s0.substr(x1+1,x2-x1-1);
                    tmp=-1;
                    //if(tmps==&quot;SYSTEM32&quot;)cout&lt;&lt;&quot;!!!&quot;;
                    if(cur==2)&#123;
                         
                        for(int k=0;k&lt;fir[last].v.size();k++)&#123;
                            if(tmps==node[fir[last].v[k]].s)&#123;
                                tmp=k;
                                break;
                            &#125;
                        &#125;
                        if(tmp==-1)&#123;
                            ++cnt;
                            node[cnt]=(E)&#123;tmps,cnt&#125;;
                            fir[last].v.push_back(cnt);
                            last=cnt;
                        &#125;
                        else&#123;
                            last=node[fir[last].v[tmp]].pla;
                        &#125;
                        /*if(tmps==&quot;SYSTEM32&quot;)&#123;
                            cout&lt;&lt;&quot;^^&quot;&lt;&lt;tmp;
                            cout&lt;&lt;&quot;&amp;&amp;&quot;&lt;&lt;last&lt;&lt;&quot;&amp;&amp;&quot;&lt;&lt;endl;
                        &#125;*/
                    &#125;
                    else&#123;
                        /*if(tmps==&quot;CERTSRV&quot;)&#123;
                            cout&lt;&lt;&quot;&amp;&amp;&quot;&lt;&lt;last&lt;&lt;&quot;&amp;&amp;&quot;&lt;&lt;endl;
                        &#125;*/
                        for(int k=0;k&lt;node[last].v.size();k++)&#123;
                            if(tmps==node[node[last].v[k]].s)&#123;
                                tmp=k;
                                break;
                            &#125;
                        &#125;
                         
                        if(tmp==-1)&#123;
                            ++cnt;
                            node[cnt]=(E)&#123;tmps,cnt&#125;;
                            node[last].v.push_back(cnt);
                            last=cnt;
                        &#125;
                        else&#123;
                            last=node[node[last].v[tmp]].pla;
                        &#125;
                    &#125;
                    //cout&lt;&lt;tmps&lt;&lt;&#39; &#39;;
                &#125;
            &#125;
            if(x1==-1&amp;&amp;x2==-1)&#123;
                cur++;
                tmps=s0.substr(0,s0.size());
                tmp=-1;
                for(int k=1;k&lt;=fircnt;k++)&#123;
                    if(tmps==fir[k].s)&#123;
                        tmp=k;
                        break;
                    &#125;
                &#125;
                if(tmp==-1)&#123;
                    ++fircnt;
                    fir[fircnt]=(E)&#123;tmps,fircnt&#125;;
                    last=fircnt;
                &#125;
                else&#123;
                    last=fir[tmp].pla;
                &#125;
                //cout&lt;&lt;tmps&lt;&lt;&#39; &#39;;
            &#125;
            else if(s0[s0.size()-1]!=&#39;\\&#39;)&#123;
                cur++;
                tmps=s0.substr(x2+1,s0.size()-x2-1);
                tmp=-1;
                if(cur==2)&#123;
                    for(int k=0;k&lt;fir[last].v.size();k++)&#123;
                        if(tmps==node[fir[last].v[k]].s)&#123;
                            tmp=k;
                            break;
                        &#125;
                    &#125;
                    if(tmp==-1)&#123;
                        ++cnt;
                        node[cnt]=(E)&#123;tmps,cnt&#125;;
                        fir[last].v.push_back(cnt);
                        last=cnt;
                    &#125;
                    else&#123;
                        last=node[fir[last].v[tmp]].pla;
                    &#125;
                &#125;
                else&#123;
                    for(int k=0;k&lt;node[last].v.size();k++)&#123;
                        if(tmps==node[node[last].v[k]].s)&#123;
                            tmp=k;
                            break;
                        &#125;
                    &#125;
                    if(tmp==-1)&#123;
                        ++cnt;
                        node[cnt]=(E)&#123;tmps,cnt&#125;;
                        node[last].v.push_back(cnt);
                        last=cnt;
                    &#125;
                    else&#123;
                        last=node[node[last].v[tmp]].pla;
                    &#125;
                &#125;
                //cout&lt;&lt;tmps&lt;&lt;&#39; &#39;;
            &#125;
            //cout&lt;&lt;endl;
        &#125;
         
        sort(fir+1,fir+1+fircnt,cmp);
        /*printf(&quot;*****测试*****\n&quot;);
        for(int i=1;i&lt;=cnt;i++)&#123;
            cout&lt;&lt;e[i].s&lt;&lt;&quot;:&quot;;
            for(int j=0;j&lt;a[i][0];j++)&#123;
                cout&lt;&lt;e[a[i][j]].s&lt;&lt;&#39; &#39;;
            &#125;
            cout&lt;&lt;endl;
        &#125;
        dfstest(trieroot);
        printf(&quot;*****测试*****\n&quot;);*/
        for(int i=1;i&lt;=fircnt;i++)&#123;
            dfs(i,0);
        &#125;
        /*cout&lt;&lt;&quot;**********&quot;&lt;&lt;endl;
        for(int i=1;i&lt;=fircnt;i++)&#123;
            cout&lt;&lt;fir[i].s&lt;&lt;endl;
        &#125;
        cout&lt;&lt;&quot;************&quot;&lt;&lt;endl;
        for(int i=1;i&lt;=cnt;i++)&#123;
            cout&lt;&lt;node[i].s&lt;&lt;endl;
        &#125;*/
        if(T) printf(&quot;\n&quot;);
    &#125;
     
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>ICPC2017Beijing J Pangu and Stones(铜牌题)</title>
    <url>/2019/08/28/ICPC2017Beijing%20J%20Pangu%20and%20Stones(%E9%93%9C%E7%89%8C%E9%A2%98)/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p>In Chinese mythology, Pangu is the first living being and the creator of the sky and the earth. He woke up from an egg and split the egg into two parts: the sky and the earth.</p>
<p>At the beginning, there was no mountain on the earth, only stones all over the land.</p>
<p>There were N piles of stones, numbered from 1 to N. Pangu wanted to merge all of them into one pile to build a great mountain. If the sum of stones of some piles was S, Pangu would need S seconds to pile them into one pile, and there would be S stones in the new pile.</p>
<p>Unfortunately, every time Pangu could only merge successive piles into one pile. And the number of piles he merged shouldn't be less than L or greater than R.</p>
<p>Pangu wanted to finish this as soon as possible.</p>
<p>Can you help him? If there was no solution, you should answer '0'.</p>
<h2 id="input">Input</h2>
<p>There are multiple test cases.</p>
<p>The first line of each case contains three integers N,L,R as above mentioned (2&lt;=N&lt;=100,2&lt;=L&lt;=R&lt;=N).</p>
<p>The second line of each case contains N integers a1,a2 …aN (1&lt;= ai &lt;=1000,i= 1…N ), indicating the number of stones of pile 1, pile 2 …pile N.</p>
<p>The number of test cases is less than 110 and there are at most 5 test cases in which N &gt;= 50. ## Output For each test case, you should output the minimum time(in seconds) Pangu had to take . If it was impossible for Pangu to do his job, you should output 0. ## Solution 石子合并，每次合并相邻的一些堆，代价是合并的石子数之和，每次合并的堆数有上下限，求最小的代价。 dp[i][j][k]表示从i合并到j，划分成k堆的最小代价。 枚举要计算的区间长度，枚举具体的区间，枚举划分的堆数，枚举具体划分方法。 dp[i][j][k]=min(dp[i][j][k],dp[i][c][k-1]+dp[c+1][j][1]); 然后枚举符合条件的划分堆和具体方法，合并成一堆。 dp[i][j][1]=min(dp[i][j][1],dp[i][c][k]+dp[c+1][j][1]+sum[j]-sum[i-1]); ## Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define ioss ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 110;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int dp[N][N][N], s[N], sum[N];</span><br><span class="line">int n,l,r;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ioss;</span><br><span class="line">    //freopen(&quot;51nod_1880_5_in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;ans.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line">        memset(dp,0x3f,sizeof(dp));</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;s[i];</span><br><span class="line">            sum[i]=sum[i-1]+s[i];</span><br><span class="line">            dp[i][i][1]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int len=2;len&lt;=n;len++)&#123;</span><br><span class="line">            for(int i=1;i+len-1&lt;=n;i++)&#123;</span><br><span class="line">                int j=i+len-1;</span><br><span class="line">                for(int k=2;k&lt;=min(len,r);k++)&#123;</span><br><span class="line">                    for(int c=i+k-2;c&lt;j;c++)&#123;</span><br><span class="line">                        dp[i][j][k]=min(dp[i][j][k],dp[i][c][k-1]+dp[c+1][j][1]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for(int k=l-1;k&lt;=r-1;k++)&#123;</span><br><span class="line">                    for(int c=i+k-2;c&lt;j;c++)&#123;</span><br><span class="line">                        dp[i][j][1]=min(dp[i][j][1],dp[i][c][k]+dp[c+1][j][1]+sum[j]-sum[i-1]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;(dp[1][n][1]==INF?0:dp[1][n][1])&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>ICPC2019南京网络赛</title>
    <url>/2019/09/01/ICPC2019%E5%8D%97%E4%BA%AC%E7%BD%91%E7%BB%9C%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="icpc2019南京网络赛">ICPC2019南京网络赛</h1>
<h2 id="b.super_log">B.super_log</h2>
<h3 id="problem">Problem</h3>
<p>求a<sup>a</sup>a...总共b个a，结果%m ### Solution <img src="https://img2018.cnblogs.com/blog/1575943/201909/1575943-20190901212807580-1412605303.png" /> 欧拉降幂 ### Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1000000;</span><br><span class="line">bool check[maxn+10];</span><br><span class="line">int phi[maxn+10];</span><br><span class="line">int prime[maxn+10];</span><br><span class="line">int tot;//素数的个数</span><br><span class="line">void phi_and_prime_table(int N)//1~n以内的所有素数  已经欧拉函数</span><br><span class="line">&#123;</span><br><span class="line">    memset(check,false,sizeof(check));</span><br><span class="line">    phi[1]=1;</span><br><span class="line">    tot=0;</span><br><span class="line">    for(int i=2;i&lt;=N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!check[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++]=i;</span><br><span class="line">            phi[i]=i-1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;tot;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i*prime[j]&gt;N) break;</span><br><span class="line">            check[i*prime[j]]=true;</span><br><span class="line">            if(i%prime[j]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i*prime[j]]=phi[i]*prime[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i*prime[j]]=phi[i]*(prime[j]-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll quick_pow(ll a,ll b,ll mod)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1) ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll lowspeed(ll a,ll b,ll p)&#123;</span><br><span class="line">    ll cur=a,ans=0;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) ans=(ans+cur)%p;</span><br><span class="line">        cur=(cur+cur)%p;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans%p;</span><br><span class="line">&#125;</span><br><span class="line">ll speed(ll a,ll b,ll p)&#123;</span><br><span class="line">    ll cur=a,ans=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) ans=lowspeed(ans,cur,p)%p;</span><br><span class="line">        cur=lowspeed(cur,cur,p)%p;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans%p;</span><br><span class="line">&#125;</span><br><span class="line">ll my_pow(ll a,ll b)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1) ans=(ans*a);</span><br><span class="line">        if(ans&gt;1e6) return ans;</span><br><span class="line">        a=(a*a);</span><br><span class="line">        if(a&gt;1e6) return a;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int T,n;</span><br><span class="line">ll a,b,m,p,ans;</span><br><span class="line">ll fun(ll x,ll las)&#123;</span><br><span class="line">    if(las==1)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(gcd(las,a)==1)&#123;</span><br><span class="line">        return speed(a,fun(x-1,phi[las])%phi[las],las);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        ll anss=1;</span><br><span class="line">        for(int i=1;i&lt;=x-1;i++)&#123;</span><br><span class="line">            anss=my_pow(a,anss);</span><br><span class="line">            if(anss&gt;=phi[las])&#123;</span><br><span class="line">                return speed(a,fun(x-1,phi[las])%phi[las]+phi[las],las);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return speed(a,anss,las);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //cout&lt;&lt;quick_pow(6,46656,600);</span><br><span class="line">    phi_and_prime_table(1000000);</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;</span><br><span class="line">        cout&lt;&lt;fun(b,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="f.greedy-sequence">F.Greedy Sequence</h2>
<h3 id="problem-1">Problem</h3>
<p>每次求区间小于i的最大值。 ### Solution 每次添加小于i的数，线段树查询。 ### Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">    int l,r,max;</span><br><span class="line">&#125; tree[N*4];</span><br><span class="line"></span><br><span class="line">int num[N];</span><br><span class="line">int a[N],b[N];</span><br><span class="line">int pos[N];</span><br><span class="line">int P;</span><br><span class="line"></span><br><span class="line">const int MAX_N=1&lt;&lt;17;//1e5</span><br><span class="line">const int INT_MINN=-1;</span><br><span class="line">int n,dat[2*MAX_N-1],x,y;</span><br><span class="line">void update(int k,int a)&#123;</span><br><span class="line">    k+=n-1;</span><br><span class="line">    dat[k]=a;</span><br><span class="line">    while(k&gt;0)&#123;</span><br><span class="line">        k=(k-1)/2;</span><br><span class="line">        dat[k]=max(dat[k*2+1],dat[k*2+2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init(int n_)&#123;</span><br><span class="line">    n=1;</span><br><span class="line">    while(n&lt;n_)&#123;</span><br><span class="line">        n*=2;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;2*n-1;i++)&#123;</span><br><span class="line">        dat[i]=INT_MINN;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n_;i++)&#123;</span><br><span class="line">        x=0;</span><br><span class="line">        update(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int a,int b,int k,int l,int r)&#123;</span><br><span class="line">    if(r&lt;=a||b&lt;=l)&#123;</span><br><span class="line">        return INT_MINN;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a&lt;=l&amp;&amp;r&lt;=b)&#123;</span><br><span class="line">        return dat[k];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int vl=query(a,b,k*2+1,l,(l+r)/2);</span><br><span class="line">        int vr=query(a,b,k*2+2,(l+r)/2,r);</span><br><span class="line">        return max(vl,vr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int a,pla;</span><br><span class="line">&#125;e[100020];</span><br><span class="line">int yyn;</span><br><span class="line">int cmp(E x,E y)&#123;</span><br><span class="line">    return x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int i,j;</span><br><span class="line">        int ans[N];</span><br><span class="line">        P=0;</span><br><span class="line">        memset(ans,0,sizeof(ans));</span><br><span class="line"></span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        yyn=n;</span><br><span class="line">        //cout&lt;&lt;yyn&lt;&lt;endl;</span><br><span class="line">        init(n);</span><br><span class="line">        for(int i=0;i&lt;yyn;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;e[i].a);</span><br><span class="line">            e[i].pla=i;</span><br><span class="line">            pos[e[i].a]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(e,e+yyn,cmp);</span><br><span class="line">        ans[1]=1;</span><br><span class="line">        for (i=2;i&lt;=yyn;i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            int maxx=0;</span><br><span class="line">            update(e[i-2].pla,e[i-2].a);</span><br><span class="line">            maxx=query(pos[i]-k,pos[i]+k+1,0,0,n); //查询小于i的最大值</span><br><span class="line">            ans[i]+=ans[maxx];</span><br><span class="line">            ans[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=yyn-1;i++)</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        cout&lt;&lt;ans[yyn]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>ICPC2019银川网 络 赛</title>
    <url>/2019/08/31/ICPC2019%E9%93%B6%E5%B7%9D%E7%BD%91%20%E7%BB%9C%20%E8%B5%9B/</url>
    <content><![CDATA[<p>真实菜鸡，被AK打蒙了，签到都最后才找到的。 ## A.Maximum Element In A Stack ### Problem 栈操作，每次操作后求最大值。 ### Solution 加入时加此时堆里的最大值，要开long long。 ### Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">const int N = 5e6+10;</span><br><span class="line"></span><br><span class="line">int n,p,q,m;</span><br><span class="line">unsigned int SA,SB,SC;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line">stack&lt;unsigned int&gt; s;</span><br><span class="line">unsigned int rng61()&#123;</span><br><span class="line">    SA ^= SA&lt;&lt;16;</span><br><span class="line">    SA ^= SA&gt;&gt;5;</span><br><span class="line">    SA ^= SA&lt;&lt;1;</span><br><span class="line">    unsigned int t = SA;SA = SB;</span><br><span class="line">    SB = SC;</span><br><span class="line">    SC ^= t ^ SA;</span><br><span class="line">    return SC;</span><br><span class="line">&#125;</span><br><span class="line">inline void PUSH(unsigned int x)&#123;</span><br><span class="line">    if(s.empty()) s.push(x);</span><br><span class="line">    else s.push(max(x,s.top()));</span><br><span class="line">&#125;</span><br><span class="line">inline void POP()&#123;</span><br><span class="line">    if(!s.empty()) s.pop();</span><br><span class="line">&#125;</span><br><span class="line">void gen()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d%u%u%u&quot;,&amp;n,&amp;p,&amp;q,&amp;m,&amp;SA,&amp;SB,&amp;SC);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(rng61() % (p+q) &lt; p)</span><br><span class="line">            PUSH(rng61() % m + 1);</span><br><span class="line">        else</span><br><span class="line">            POP();</span><br><span class="line">        if(s.empty()) a[i]=0;</span><br><span class="line">        else a[i]=s.top();</span><br><span class="line">        a[i]*=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;cin &gt;&gt; T;</span><br><span class="line">    for(int i=1;i&lt;=T;i++)&#123;</span><br><span class="line">        while(!s.empty()) s.pop();</span><br><span class="line">        gen();</span><br><span class="line">        ll ans=a[1];</span><br><span class="line">        for(int j=2;j&lt;=n;j++)</span><br><span class="line">            ans^=a[j];</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## B.Rolling The Polygon 一开始看计算几何就没做，最后半小时发现很简单，298分钟过的... ### Problem 给一个凸多边形和其内一点，求凸多边形在地下转一周，点走过的距离。 ### Solution 每个角都走一个圆弧，求出半径和补角，相乘即可。 ### Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">int T,n;</span><br><span class="line">int cnt=0,sx,sy;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;e[60];</span><br><span class="line"></span><br><span class="line">double anss;</span><br><span class="line">double l(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+0.0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //cout&lt;&lt;acos(-1/sqrt(2.0));</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        anss=0;</span><br><span class="line">        cnt++;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;e[i].x,&amp;e[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;sx,&amp;sy);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int x1,x2,y1,y2;</span><br><span class="line">            double tmp1=l(sx,sy,e[i].x,e[i].y);</span><br><span class="line">            if(i==1)&#123;</span><br><span class="line">                x1=e[n].x-e[1].x,y1=e[n].y-e[1].y;</span><br><span class="line">                x2=e[2].x-e[1].x,y2=e[2].y-e[1].y;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(i==n)&#123;</span><br><span class="line">                x1=e[n-1].x-e[n].x,y1=e[n-1].y-e[n].y;</span><br><span class="line">                x2=e[1].x-e[n].x,y2=e[1].y-e[n].y;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                x1=e[i-1].x-e[i].x,y1=e[i-1].y-e[i].y;</span><br><span class="line">                x2=e[i+1].x-e[i].x,y2=e[i+1].y-e[i].y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //cout&lt;&lt;&#x27;*&#x27;&lt;&lt;y1&lt;&lt;&#x27;*&#x27;&lt;&lt;endl;</span><br><span class="line">            double tmp2=acos(-1)-(acos((x1*x2+y1*y2)*1.0/l(x1,y1,0,0)/l(x2,y2,0,0)));</span><br><span class="line">            anss+=tmp1*tmp2;</span><br><span class="line">            //cout&lt;&lt;i&lt;&lt;&#x27;:&#x27;&lt;&lt;tmp1&lt;&lt;&#x27; &#x27;&lt;&lt;tmp2&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %.3f\n&quot;,cnt,anss);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## C.Caesar Cipher ### Problem 字母后移，给出示范和目标串，求原串。 ### Solution 模拟 ### Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">int n,m;</span><br><span class="line">char a[N],b[N],c[N],ans[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    for(int i=1;i&lt;=T;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        scanf(&quot;%s%s%s&quot;,a,b,c);</span><br><span class="line">        int d=b[0]-a[0];</span><br><span class="line">        int j=0;</span><br><span class="line">        for(j=0;j&lt;m;j++)&#123;</span><br><span class="line">            int ss=c[j]-d;</span><br><span class="line">            while(ss&lt;&#x27;A&#x27;) ss+=26;</span><br><span class="line">            while(ss&gt;&#x27;Z&#x27;) ss-=26;</span><br><span class="line">            ans[j]=ss;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[j]=&#x27;\0&#x27;;</span><br><span class="line">        printf(&quot;Case #%d: %s\n&quot;,i,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## D.Take Your Seat ### Problems n个乘客分别属于n个座位，顺序坐，第一个随机坐，后面的如果被占了就随机，否则坐自己的，求最后一个坐自己位置的概率。 m同样，不过乘客坐座位顺序随机。 ### Solution n=1显然为1，n=2显然为1/2，n=3的时候，P(3)=1/3<em>(1+P(2)+0)，n=4，P(4)=1/4</em>(1+P(3)+P(2)+0)。</p>
<p>以4为例解释，1号坐在每个位置概率为1/4，当他坐在自己位置，4号必然坐到自己位置，概率为1；1号坐在2号，相当于2号随机坐（疯了），2号的原位置可以视作1，整个删除1号和他坐的2号位置，问题变为P(3)；1号坐在3号位置，2号坐对了，他也删去，规模变为P(2)；1号坐在4号，概率为0。</p>
<p>所以推测不是1的时候概率都是1/2，可以直接敲了（或者数学归纳法证明）。</p>
<p>m=1时也是1，1号最后登机时坐在自己位置概率为1，否则可以视作他前面的都正常删去，转化为第一个问题，则m不是1时，P(m)=1/m<em>(1+1/2</em>(m-1))。</p>
<h3 id="code">Code</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">int T,n,m;</span><br><span class="line">int cnt=0,sx,sy;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;e[60];</span><br><span class="line"></span><br><span class="line">double anss;</span><br><span class="line">double l(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+0.0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //cout&lt;&lt;acos(-1/sqrt(2.0));</span><br><span class="line">    //io_opt;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        double ans1=(n==1?1.0:0.5),ans2=(m==1?1:(m+1)/2.0/m);</span><br><span class="line">        printf(&quot;Case #%d: %.6f %6f\n&quot;,cnt,ans1,ans2);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="h.fight-against-monsters">H.Fight Against Monsters</h2>
<h3 id="problem">Problem</h3>
<p>回合制，勇士打n个怪，每个有hp和atk（血量和攻击），勇士打每一个怪的伤害分别计算，第一次是1，第二次是2，每次加1，怪物先手，问勇士受到的最小伤害。 ### Solution hp转成击败次数，贪心，除法排序。 ### Code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">int T,n;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int hp,atk;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;e[100020];</span><br><span class="line">int cmp(E x,E y)&#123;</span><br><span class="line">    if(x.atk*y.hp==y.atk*x.hp) return x.atk&lt;y.atk;</span><br><span class="line">    return x.atk*y.hp&lt;y.atk*x.hp;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int x,int s)&#123;</span><br><span class="line">    return x&gt;=s;</span><br><span class="line">&#125;</span><br><span class="line">int ef(int s)&#123;</span><br><span class="line">    int l=1,r=1e3,mid,ans;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;1;</span><br><span class="line">        if(check((mid+1)*mid/2,s))&#123;</span><br><span class="line">            r=mid-1;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            l=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int cnt=0;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;e[i].hp&gt;&gt;e[i].atk;</span><br><span class="line">            e[i].hp=ef(e[i].hp);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(e+1,e+1+n,cmp);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(i==1)&#123;</span><br><span class="line">                e[i].sum=e[i].atk;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                e[i].sum=e[i-1].sum+e[i].atk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=0,tmp;</span><br><span class="line">        for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">            //cout&lt;&lt;e[i].hp&lt;&lt;endl;</span><br><span class="line">            tmp=e[i].hp;</span><br><span class="line">            tmp*=e[i].sum;</span><br><span class="line">            ans+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # Continue...</p>
]]></content>
  </entry>
  <entry>
    <title>POJ1505 Copying Books</title>
    <url>/2019/08/01/POJ1505%20Copying%20Books/</url>
    <content><![CDATA[<p>ZOJ2002 ##题目</p>
<p>Before the invention of book-printing, it was very hard to make a copy of a book. All the contents had to be re-written by hand by so called scribers. The scriber had been given a book and after several months he finished its copy. One of the most famous scribers lived in the 15th century and his name was Xaverius Endricus Remius Ontius Xendrianus (Xerox). Anyway, the work was very annoying and boring. And the only way to speed it up was to hire more scribers.</p>
<p>Once upon a time, there was a theater ensemble that wanted to play famous Antique Tragedies. The scripts of these plays were divided into many books and actors needed more copies of them, of course. So they hired many scribers to make copies of these books. Imagine you have m books (numbered 1, 2 ... m) that may have different number of pages (p1, p2 ... pm) and you want to make one copy of each of them. Your task is to divide these books among k scribes, k &lt;= m. Each book can be assigned to a single scriber only, and every scriber must get a continuous sequence of books. That means, there exists an increasing succession of numbers 0 = b0 &lt; b1 &lt; b2, ... &lt; bk-1 &lt;= bk = m such that i-th scriber gets a sequence of books with numbers between bi-1+1 and bi. The time needed to make a copy of all the books is determined by the scriber who was assigned the most work. Therefore, our goal is to minimize the maximum number of pages assigned to a single scriber. Your task is to find the optimal assignment.</p>
<p>##题意</p>
<p>给一段不下降的子序列，要求分成k段，使每一段的和的最大值最小，若有多组答案，输出依次满足：第一组和尽量小，第二组和尽量小，第三组和尽量小。。。的答案。</p>
<p>##思路</p>
<p>二分+贪心，二分出来的段数如果小于k，就从前向后分段。</p>
<p>#注意二分上下界！！！</p>
<p>##代码</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;algorithm&gt;
#define ll long long
#include&lt;cmath&gt;
#define exp 0.000000001
using namespace std;
ll T,m,k,cntt;
ll a[520],f[520];
bool check(ll x)&#123;
    memset(f,false,sizeof(f));
    ll cur=0,cnt=1;
    for(int i=m;i&gt;=1;i--)&#123;
        cur+=a[i];
        if(cur&gt;x)&#123;
            cnt++;
            cur=a[i];
            f[i]=true;
        &#125;
    &#125;
    cntt=cnt;
    return cnt&lt;=k;
&#125;
int main()&#123;
    cin&gt;&gt;T;
    while(T--)&#123;
        ll l=0,r=0;
        scanf(&quot;%lld%lld&quot;,&amp;m,&amp;k);
        for(ll i=1;i&lt;=m;i++)&#123;
            scanf(&quot;%lld&quot;,&amp;a[i]);
            if(a[i]&gt;l) l=a[i];//此处很关键 
            r+=a[i];
        &#125;
        ll mid,ans;
        while(l&lt;=r)&#123;
            mid=(l+r)&gt;&gt;1;
            if(check(mid))&#123;
                r=mid-1;
                ans=mid;
            &#125;
            else&#123;
                l=mid+1;
                
            &#125;
        &#125;
        check(ans);
        //cout&lt;&lt;&quot;!!&quot;&lt;&lt;cntt&lt;&lt;endl;
        for(int i=1;i&lt;=m&amp;&amp;cntt&lt;k;i++)&#123;
            if(!f[i]) f[i]=true,cntt++;
        &#125;
        for(int i=1;i&lt;=m;i++)&#123;
            cout&lt;&lt;a[i];
            if(i!=m) cout&lt;&lt;&#39; &#39;;
            if(f[i]) cout&lt;&lt;&quot;/ &quot;;
        &#125;
        cout&lt;&lt;endl;
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>POJ2287 Tian Ji -- The Horse Racing</title>
    <url>/2019/08/01/POJ2287%20Tian%20Ji%20--%20The%20Horse%20Racing/</url>
    <content><![CDATA[<p>##题目</p>
<p><a href="http://poj.org/problem?id=2287">POJ2287</a></p>
<p>##思路</p>
<p>全网建议看这篇，看懂了再去看其他的就明白为啥这么说了。。。</p>
<p><a href="https://blog.csdn.net/weixin_44389276/article/details/89060436">田忌赛马（贪心） - Nothing9826的博客 - CSDN博客</a></p>
<p>##代码</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
ll n;
ll a[1020],b[1020];
int cmp(ll x,ll y)&#123;
    return x&gt;y;
&#125;
ll ans=0;
int main()&#123;
    while(scanf(&quot;%lld&quot;,&amp;n)==1&amp;&amp;n)&#123;
        ans=0;
        for(int i=1;i&lt;=n;i++)&#123;
            scanf(&quot;%lld&quot;,&amp;a[i]);
        &#125;
        for(int i=1;i&lt;=n;i++)&#123;
            scanf(&quot;%lld&quot;,&amp;b[i]);
        &#125;
        sort(a+1,a+1+n,cmp);
        sort(b+1,b+1+n,cmp);
        int poi=1;
        int i=1,j=n,k=1,l=n;
        for(int s=1;s&lt;=n;s++)&#123;
            if(a[i]&gt;b[k])&#123;
                i++,k++;
                ans++;
            &#125;
            else if(a[j]&gt;b[l])&#123;
                ans++;
                j--,l--;
            &#125;
            else&#123;
                if(a[j]&lt;b[k]) ans--;
                
                j--,k++;
            &#125;
        &#125;
        cout&lt;&lt;ans*200&lt;&lt;endl;
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>wait</title>
    <url>/2019/08/09/wait/</url>
    <content><![CDATA[<p><span class="math display">\[y = x^2\]</span></p>
<p>可以创建行内公式，例如 <span class="math inline">\(\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N\)</span>。或者块级公式：</p>
<p><span class="math display">\[  x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} \]</span></p>
]]></content>
  </entry>
  <entry>
    <title>乘法逆元(从入门到批量求解)(正在学欧拉筛)</title>
    <url>/2019/07/27/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83(%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%89%B9%E9%87%8F%E6%B1%82%E8%A7%A3)(%E6%AD%A3%E5%9C%A8%E5%AD%A6%E6%AC%A7%E6%8B%89%E7%AD%9B)/</url>
    <content><![CDATA[<blockquote>
<p>在做各种取余运算时，我们会发现先除和先取余的结果是不同的，这会导致计算难度的加大，乘法逆元可以解决类似的分数取余问题。</p>
</blockquote>
<blockquote>
<p>本文按照博主的学习思路排序，结论为<strong>（单个）费马小定理求乘法逆元</strong>、<strong>（单个）利用扩展欧几里得任意情况下求乘法逆元</strong>、<strong>（批量）线性递推求乘法逆元</strong></p>
</blockquote>
<p>##同余的运算法则之一</p>
<p>定理3 ac≡bc(mod m)，且若(m,c)≡d，则a≡b(mod m/d)。——数论讲义</p>
<p>也就是说，同余式两边可以同除一个和模数互质的数（此时模数不变）。</p>
<p>##费马小定理</p>
<p>形式1：<strong>若m是素数，则a^m≡a(mod m)。——数论讲义</strong>······①</p>
<p>形式2：<strong>如果m是一个素数，而整数a不是m的倍数，则有a^(m-1)≡1(mod m)。——某百科</strong>······②</p>
<p>###<strong><em>由于m是一个素数，因此①到②的条件：除数a和模数m互质，等价于a不是m的倍数。</em></strong></p>
<p>##费马小定理②的推论</p>
<p>###<strong>a^(m-1)≡1(mod m) =&gt; a*a^(m-2)≡1(mod m) =&gt; a^(m-2)≡1/a(mod m)</strong></p>
<p>##乘法逆元</p>
<p>对于正整数a和m，如果有ax≡1(mod m)，那么把这个同余方程中x的最小正整数解叫做a模m的逆元。</p>
<p><em>若a与m不互质，易证ax%m!=1，故a必与m互质</em></p>
<p>##乘法逆元与费马小定理的推论</p>
<p>如果m是素数，有以下推论:</p>
<p>###<strong>ax≡1(mod m) =&gt; x≡1/a(mod m) =&gt; x≡a^(m-2)(mod m)</strong></p>
<p>(同余的传递性)</p>
<p>##（单个）费马小定理求乘法逆元</p>
<p>计算(a/b)%m：</p>
<p>若<strong>m是素数</strong>：</p>
<p>将1/b替换成逆元x，即b^(m-2)%m。</p>
<p>答案为(a*b^(m-2))%m。</p>
<p>###例题</p>
<p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1013" title="51Nod1013 3的幂的和">51Nod1013</a></p>
<p>###代码</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define db double
#define mod 1000000007
ll n;
ll speed(ll a,ll b,ll p)&#123;
    ll cur=a,ans=1;
    while(b)&#123;
        if(b&amp;1) ans=ans*cur%p;
        cur=cur*cur%p;
        b&gt;&gt;=1;
    &#125;
    return ans%p;
&#125;
int main()&#123;
    cin&gt;&gt;n;
    ll ans=((speed(3,n+1,mod)-1)*speed(2,mod-2,mod))%mod;
    cout&lt;&lt;ans&lt;&lt;endl;
    //cout&lt;&lt;speed(2,mod-2,mod)%mod;
    return 0;
&#125;</code></pre>
<p><strong>为了方便求任意情况的逆元，我们先来补充几个概念：</strong></p>
<p>##欧几里得算法</p>
<p>log时间内求解最大公约数。</p>
<p>###代码</p>
<pre><code>ll gcd(ll a,llb)&#123;
    return b==0?a:gcd(b,a%b);
&#125;</code></pre>
<p>###证明</p>
<p><a href="https://www.cnblogs.com/zwffff/archive/2010/08/25/1808178.html" title="【整理】辗转相除法求最大公约数算法证明 - 凌风有约 - 博客园">辗转相除法求最大公约数算法证明</a></p>
<p>##贝祖定理</p>
<p>设a,b是整数，则存在整数x,y，使得ax+by=gcd(a,b)</p>
<p>##扩展欧几里得算法</p>
<p>####求贝祖定理中x和y的解，即求使ax+by=gcd(a,b)的x和y。</p>
<p>我们利用gcd来求，当递归到最内层时，a=gcd(a,b)，b=0，因此x=1，y=0。</p>
<p>假设我们已经得到内层x1，y1，对于外层a，b有a%b=a-(a/b)*b</p>
<pre><code>外层：a*x+b*y=gcd(a,b)

内层：b*x1+(a-(a/b)*b)*y1=gcd(a,b)</code></pre>
<p>展开对比可得：</p>
<pre><code>x=y1
y=x1-a/b*y1</code></pre>
<p>###代码</p>
<pre><code>ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;//扩展欧几里得算法
    if(b==0)&#123;//递归边界 
        x=1;y=0;
        return a;
    &#125;
    ll ret=exgcd(b,a%b,x,y);
    ll tmp=y;//求解原x,y     
    y=x-a/b*y;
    x=tmp;
    return ret;//返回gcd      
&#125;</code></pre>
<p>###参考</p>
<p><a href="https://blog.csdn.net/destiny1507/article/details/81750874" title="扩展欧几里得算法详解">扩展欧几里得算法详解</a></p>
<p>##（单个）利用扩展欧几里得任意情况下求乘法逆元</p>
<p>计算(a/b)%m：</p>
<p>仍需要逆元存在，即b与m互质。</p>
<p>构造bx+my=gcd(b,m)=1，用exgcd求出来的x即为逆元。</p>
<p>代码与前面相同。</p>
<p><strong>注意这里参数传m和-m都一样，答案要加m再%m。</strong></p>
<p>###参考</p>
<p><a href="https://www.jianshu.com/p/7876eb2dff89" title="欧几里得算法心得(辗转相除法) - 简书">欧几里得算法心得(辗转相除法)</a></p>
<p>##（批量）线性递推求乘法逆元</p>
<p>给定n,p求1~n中所有整数在模p意义下的乘法逆元。</p>
<p>n为3e6，p&gt;n且为质数。</p>
<p><a href="https://www.luogu.org/problem/P3811" title="P3811 【模板】乘法逆元 - 洛谷 | 计算机科学教育新生态">洛谷P3811 【模板】乘法逆元</a></p>
<p>此时用单个求法会超时，我们可以推导递推公式。</p>
<p>本垃圾博主还不会用公式编辑器，于是看这里↓</p>
<p><a href="https://www.cnblogs.com/qdscwyy/p/7795368.html?tdsourcetag=s_pcqq_aiomsg" title="线性求逆元 - Grary - 博客园">线性求逆元 - Grary - 博客园</a></p>
<p>试了试，这里p也必须是质数，还不知道为什么（逃</p>
<p>###代码</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const ll MAXN=3e6+20;
ll inv[MAXN];
ll n,mod;
void preinv(ll num,ll p)&#123;
    inv[0]=inv[1]=1;
    for(ll i=2;i&lt;=num;i++)&#123;
        inv[i]=(p-p/i)*inv[p%i]%p;
    &#125;
&#125;
int main()&#123;
    cin&gt;&gt;n&gt;&gt;mod;
    preinv(n,mod);
    for(ll i=1;i&lt;=n;i++)&#123;
        printf(&quot;%lld\n&quot;,inv[i]);
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2019/02/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>终于下定决心不碰运气写二分了。。。</p>
<p>思路比较乱，建议直接点进参考①</p>
<p>来说一下我记忆的方法</p>
<p>注意left&lt;=right</p>
<p>首先标准查找是随机的找到一个，分三类，找不到返回-1</p>
<p>然后如果要找第一个和最后一个，因为是准确查找，所以要有判别和找不到返回-1</p>
<p>里面的大于还是大于等于，要具体分析。（分析相等的时候向左找还是向右找，返回谁）</p>
<p>举个例子</p>
<p>寻找最后一个相等的，没有的话找比key小的最后一个（searchLastEqualOrSmaller）</p>
<p>这两个元素的位置都是偏右（比如说{1,2,3,4,4,4,5,6}，分成1,2,3|4,4,4|5,6，3和最后一个4都在所在区间的右边），因此要向右找，让相等的情况跟着缩小左边界，因此是大于</p>
<p>解释一下为什么返回right，根据while结束条件，最后right&lt;right，如果没有相等的，arr[right]&lt;key&lt;arr[left]，否则，key==arr[right]&lt;arr[left]（所以返回left就是比key大的第一个）</p>
<p>大于等于同理</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 //递增 
 2 #include&lt;cstdio&gt;
 3 #include&lt;iostream&gt;
 4 #include&lt;cstring&gt;
 5 #include&lt;algorithm&gt;
 6 using namespace std;
 7 int search(int *arr,int n,int key)&#123;
 8     int left=0,right=n-1;
 9     while(left&lt;=right)&#123;
10         int mid=(left+right)&gt;&gt;1;
11         if(arr[mid]==key) return mid;
12         else if(arr[mid]&gt;key) right=mid-1;
13         else left=mid+1;
14     &#125;
15     return -1;
16 &#125;
17 int searchFirstEqual(int *arr,int n,int key)&#123;
18     int left=0,right=n-1;
19     while(left&lt;=right)&#123;
20         int mid=(left+right)&gt;&gt;1;
21         if(arr[mid]&gt;=key) right=mid-1;
22         else left=mid+1;
23     &#125;
24     if(left&lt;n&amp;&amp;arr[left]==key)&#123;
25         return left;
26     &#125;
27     return -1;
28 &#125;
29 int searchLastEqual(int *arr,int n,int key)&#123;
30     int left=0,right=n-1;
31     while(left&lt;=right)&#123;
32         int mid=(left+right)&gt;&gt;1;
33         if(arr[mid]&gt;key) right=mid-1;
34         else left=mid+1;
35     &#125;
36     if(right&gt;=0&amp;&amp;arr[right]==key)&#123;
37         return right;
38     &#125;
39     return -1;
40 &#125;
41 int searchLastEqualOrSmaller(int *arr,int n,int key)&#123;
42     int left=0,right=n-1;
43     while(left&lt;=right)&#123;
44         int mid=(left+right)&gt;&gt;1;
45         if(arr[mid]&gt;key) right=mid-1;
46         else left=mid+1;
47     &#125;
48     return right;
49 &#125;
50 int searchLastSmaller(int *arr,int n,int key)&#123;
51     int left=0,right=n-1;
52     while(left&lt;=right)&#123;
53         int mid=(left+right)&gt;&gt;1;
54         if(arr[mid]&gt;=key) right=mid-1;
55         else left=mid+1;
56     &#125;
57     return right;
58 &#125;
59 int searchFirstEqualOrLarger(int *arr,int n,int key)&#123;
60     int left=0,right=n-1;
61     while(left&lt;=right)&#123;
62         int mid=(left+right)&gt;&gt;1;
63         if(arr[mid]&gt;=key) right=mid-1;
64         else left=mid+1;
65     &#125;
66     return left;
67 &#125;
68 int searchFirstLarger(int *arr,int n,int key)&#123;
69     int left=0,right=n-1;
70     while(left&lt;=right)&#123;
71         int mid=(left+right)&gt;&gt;1;
72         if(arr[mid]&gt;key) right=mid-1;
73         else left=mid+1;
74     &#125;
75     return left;
76 &#125;
77 
78 int main()&#123;
79     int arr[17] = &#123;1, 
80                    2, 2, 5, 5, 5, 
81                    5, 5, 5, 5, 5, 
82                    5, 5, 6, 6, 7&#125;;
83     printf(&quot;First Equal           : %2d \n&quot;, searchFirstEqual(arr, 16, 5));
84     printf(&quot;Last Equal            : %2d \n&quot;, searchLastEqual(arr, 16, 5));
85     printf(&quot;First Equal or Larger : %2d \n&quot;, searchFirstEqualOrLarger(arr, 16, 5));
86     printf(&quot;First Larger          : %2d \n&quot;, searchFirstLarger(arr, 16, 5));
87     printf(&quot;Last Equal or Smaller : %2d \n&quot;, searchLastEqualOrSmaller(arr, 16, 5));
88     printf(&quot;Last Smaller          : %2d \n&quot;, searchLastSmaller(arr, 16, 5));
89     return 0;
90     return 0;
91 &#125;</code></pre>
<p>View Code</p>
<p>参考：①<a href="https://www.cnblogs.com/luoxn28/p/5767571.html">你真的会写二分查找吗 - luoxn28 - 博客园</a></p>
<p>②<a href="http://blog.chinaunix.net/uid-1844931-id-3337784.html">你真的会写二分检索吗？-liubird- ChinaUnix博客</a>（测试段代码来源）</p>
]]></content>
  </entry>
  <entry>
    <title>二叉树问题</title>
    <url>/2019/06/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>现给定一棵二叉树的先序遍历序列和中序遍历序列，要求你计算该二叉树的高度。</p>
<p>###输入</p>
<p>输入包含多组测试数据，每组输入首先给出正整数N（&lt;=50），为树中结点总数。下面2行先后给出先序和中序遍历序列，均是长度为N的不包含重复英文字母（区别大小写）的字符串。</p>
<p>###输出</p>
<p>对于每组输入，输出一个整数，即该二叉树的高度。</p>
<p>###样例输入</p>
<blockquote>
<p>9 ABDFGHIEC FDHGIBEAC 7 Abcdefg gfedcbA</p>
</blockquote>
<p>###样例输出 &gt; 5 &gt; 7</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#define ll long long
using namespace std;
map&lt;char,int&gt;q;
int n,h[1024],ans;
string s1,s2;
int lson[1024],rson[1024];
int tag[1024];
char buildtree(int s,int t)&#123;
    memset(tag,0,sizeof(tag));
    if(s==t) return s2[s];
    for(int i=s;i&lt;=t;i++)&#123;
        tag[s2[i]]=1;
        //cout&lt;&lt;s2[i];
    &#125;
    //cout&lt;&lt;endl;
    int lx=-1,rx=-1;
    for(int i=0;i&lt;n;i++)&#123;
        if(lx==-1)&#123;
            if(tag[s1[i]])&#123;
                lx=i;
            &#125;
        &#125;
        else&#123;
            if(!tag[s1[i]])&#123;
                rx=i-1;
                break;
            &#125;
        &#125;
    &#125;
    if(rx==-1) rx=t;
    char root=s1[lx];int pla;
    for(int i=s;i&lt;=t;i++)&#123;
        if(root==s2[i])&#123;
            pla=i;
            break;
        &#125;
    &#125;
    if(s&lt;=pla-1) lson[root]=buildtree(s,pla-1);
    if(pla+1&lt;=t) rson[root]=buildtree(pla+1,t);
    return root;
&#125;
void dfs(char ss)&#123;
    if(ss==0)&#123;
        return;
    &#125;
    ans=max(ans,h[ss]);
    h[lson[ss]]=h[rson[ss]]=h[ss]+1;
    dfs(lson[ss]);
    dfs(rson[ss]);//cout&lt;&lt;ss&lt;&lt;&#39;*&#39;;
&#125;
int main()&#123;
    while(cin&gt;&gt;n)&#123;
        memset(h,0,sizeof(h));
        memset(lson,0,sizeof(lson));
        memset(rson,0,sizeof(rson));
        ans=0;
        //q.erase(q.begin(),q.end());
        cin&gt;&gt;s1&gt;&gt;s2;
        char x=buildtree(0,n-1);
        h[x]=1;
        dfs(x);
        cout&lt;&lt;ans&lt;&lt;endl;
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>二叉排序树</title>
    <url>/2019/06/23/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>输入一系列整数，建立二叉排序数，并进行前序，中序，后序遍历。</p>
<p>###输入</p>
<p>输入第一行包括一个整数n(1&lt;=n&lt;=100)。接下来的一行包括n个整数。</p>
<p>###输出</p>
<p>可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。每种遍历结果输出一行。每行最后一个数据之后有一个空格。</p>
<p>###样例输入 &gt; 1 &gt; 2 &gt; 2 &gt; 8 15 &gt; 4 &gt; 21 10 5 39</p>
<p>###样例输出 &gt; 2 &gt; 2 &gt; 2 &gt; 8 15 &gt; 8 15 &gt; 15 8 &gt; 21 10 5 39 &gt; 5 10 21 39 &gt; 5 10 39 21</p>
<p>####瞎搞的。。。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define ll long long
#define INF -72340172838076674
using namespace std;
ll n;
struct E&#123;
    ll num,lson,rson;
&#125;e[120];
ll cnt=0,root=INF;
ll find(ll x)&#123;
    x=e[x].num;
    ll cur=root;
    while(1)&#123;
        if(x&lt;e[cur].num)&#123;
            if(e[cur].lson==INF)&#123;
                return cur;
            &#125;
            else&#123;
                cur=e[cur].lson;
            &#125;
        &#125;
        else if(x&gt;e[cur].num)&#123;
            if(e[cur].rson==INF)&#123;
                return cur;
            &#125;
            else&#123;
                cur=e[cur].rson;
            &#125;
        &#125;
        else return INF;
    &#125;
&#125;
void Insert(ll x)&#123;
    if(!cnt)&#123;
        cnt++;
        root=x;
        return; 
    &#125;
    ll fat=find(x);
    if(fat==INF) return;
    cnt++;
    if(e[x].num&gt;e[fat].num)&#123;
        e[fat].rson=x;
    &#125;
    else&#123;
        e[fat].lson=x;
    &#125;
    return;
&#125;
void dfs1(ll x)&#123;
    if(x==INF) return;
    cout&lt;&lt;e[x].num&lt;&lt;&#39; &#39;;
    dfs1(e[x].lson);
    dfs1(e[x].rson);
&#125;
void dfs2(ll x)&#123;
    if(x==INF) return;
    dfs2(e[x].lson);
    cout&lt;&lt;e[x].num&lt;&lt;&#39; &#39;;
    dfs2(e[x].rson);
&#125;
void dfs3(ll x)&#123;
    if(x==INF) return;
    dfs3(e[x].lson);
    dfs3(e[x].rson);
    cout&lt;&lt;e[x].num&lt;&lt;&#39; &#39;;
&#125;
int main()&#123;
    while(cin&gt;&gt;n)&#123;
        root=INF,cnt=0;
        memset(e,-0x2,sizeof(e));
        for(int i=1;i&lt;=n;i++)&#123;
            ll x;
            cin&gt;&gt;x;
            e[i].num=x;
            Insert(i);
        &#125;
        dfs1(root);
        cout&lt;&lt;endl;
        dfs2(root);
        cout&lt;&lt;endl;
        dfs3(root);
        cout&lt;&lt;endl;
    &#125;
     
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>卡特兰数</title>
    <url>/2019/06/05/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
    <content><![CDATA[<p>一、引入</p>
<p>出栈序</p>
<p>二、推导（摘自百度百科）</p>
<p>对于每一个数来说，必须进栈一次、出栈一次。我们把<a href="https://baike.baidu.com/item/%E8%BF%9B%E6%A0%88">进栈</a>设为状态'1'，出栈设为状态'0'。n个数的所有状态对应n个1和n个0组成的2n位<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0">二进制数</a>。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于<a href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88">出栈</a>的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。</p>
<p>在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。</p>
<p>不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n- m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。</p>
<p>反过来，任何一个由n+1个0和n-1个1组成的2n位<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0">二进制数</a>，由于0的个数多2个，2n为<a href="https://baike.baidu.com/item/%E5%81%B6%E6%95%B0">偶数</a>，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。</p>
<p>因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。</p>
<p>显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n-1)=c(2n,n)/(n+1)=h(n)。</p>
<p>三、应用</p>
<p>给定n对括号，求括号匹配的种数。</p>
<p>出栈限制类问题。</p>
]]></content>
  </entry>
  <entry>
    <title>做题中踩过的坑。。。</title>
    <url>/2019/03/02/%E5%81%9A%E9%A2%98%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%E3%80%82%E3%80%82%E3%80%82/</url>
    <content><![CDATA[<p>1、long long=int<em>int，会数据溢出，直接定义long long或者long long</em>=long long。（51Nod1082）</p>
<p>2、不要再忘记题目条件了！输出No Solution！！！！（51Nod1090）</p>
<p>3、二分答案可以在修改边界的过程中留一个ans=mid，要向上取整可以（n+mod-1）%mod，注意不要除以0。（POJ3104）</p>
<p>4、别人的程序初始化要看清楚。。。（POJ2976）</p>
<p>5、变量的重名问题！！！</p>
<p>6、重新检查题意！</p>
<p>7、不要偷懒，例如输入两个-1结束，就去判两个-1。</p>
<p>8、有时需要考虑给的数据是否满足前一个小于后一个，题目中不说可能不满足。</p>
<p>9、贪心和二分的正确性，有点玄学。</p>
<p>10、多组输入注意不要提前break掉，开平方不要开复数。（POJ1328）</p>
<p>11、注意修改变量的顺序！！！比如去掉最大公约数要先提取到一个变量，不能两次调用函数！！！</p>
<p>12、循环i套i。</p>
<p>太傻了，不更新了，反正也不太会回来看，刷点题睡个好觉状态就有了。</p>
]]></content>
  </entry>
  <entry>
    <title>取石子游戏</title>
    <url>/2019/06/05/%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>一天小明和小红在玩取石子游戏，游戏规则是这样的：<br />
（1）本游戏是一个二人游戏；<br />
（2）有一堆石子，共有n个；<br />
（3）两人轮流进行；<br />
（4）每走一步可以取走1~m个石子；<br />
（5）最先取光石子的一方为胜。<br />
如果游戏的双方使用的都是最优策略，请输出哪个人能赢。</p>
<h2 id="输入">输入</h2>
<p>输入的第一行是一个正整数C（C&lt;=100），表示有C组测试数据。<br />
每组输入两个整数n和m（1&lt;=n,m&lt;=1000），n和m的含义见题目描述。</p>
<h2 id="输出">输出</h2>
<p>对于每组输入，如果先走的人能赢，请输出&quot;first&quot;，否则请输出&quot;second&quot;。</p>
<h2 id="样例输入">样例输入</h2>
<pre><code>2
23 2
4 3</code></pre>
<h2 id="样例输出">样例输出</h2>
<pre><code>first
second  
  
考虑第一个人什么时候赢，如果石子数为1到m，赢，m+1输，m+2可以让对方为m+1，赢，2m+2时怎么取都大于m+1输，2m+3可以取到2m+2让对方输，以此类推，如果n是m+1的整数倍，则A输，否则B输。  
代码  </code></pre>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;cmath&gt;
 4 #include&lt;cstring&gt;
 5 #include&lt;algorithm&gt;
 6 #define ll long long
 7 using namespace std;
 8 int T,n,m;
 9 int main()&#123;
10     cin&gt;&gt;T;
11     while(T--)&#123;
12         cin&gt;&gt;n&gt;&gt;m;
13         if(n%(m+1))&#123;
14             cout&lt;&lt;&quot;first\n&quot;;
15         &#125;
16         else cout&lt;&lt;&quot;second\n&quot;;
17     &#125;
18     return 0;
19 &#125;</code></pre>
<p>View Code</p>
]]></content>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/2019/06/23/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和。</p>
<p>###输入</p>
<p>输入有多组数据。 每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。</p>
<p>###输出</p>
<p>输出权值。</p>
<p>###样例输入 &gt; 2 &gt; 2 8 &gt; 3 &gt; 5 11 30</p>
<p>###样例输出 &gt; 10 &gt; 62</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;
#define ll long long
using namespace std;
ll n,ans,h[5020];
struct E&#123;
    ll k,l,r,t;
    friend bool operator &lt; (E x,E y)&#123;return x.k&gt;y.k;&#125;
&#125;e[5020];
priority_queue&lt;E&gt;q;
void dfs(ll root)&#123;
    if(root==0) return;
    ll ls=e[root].l,rs=e[root].r;
    h[ls]=h[rs]=h[root]+1;
    if(ls==0&amp;&amp;rs==0)&#123;
        ans+=e[root].k*h[root];
    &#125;
    dfs(ls);
    dfs(rs);
&#125;
int main()&#123;
    while(cin&gt;&gt;n)&#123;
        ll cur=n;ans=0;
        memset(h,0,sizeof(h));
        for(ll i=1;i&lt;=n;i++)&#123;
            ll x;
            cin&gt;&gt;x;
            e[i].k=x;
            e[i].l=0;
            e[i].r=0;
            e[i].t=i;
            q.push(e[i]);
        &#125;
        while(q.size()&gt;1)&#123;
            E xx=q.top();q.pop();
            E yy=q.top();q.pop();
            //cout&lt;&lt;xx.k&lt;&lt;&#39; &#39;&lt;&lt;yy.k&lt;&lt;endl;
            E neww=(E)&#123;xx.k+yy.k,xx.t,yy.t,++cur&#125;;
            e[cur]=neww;
            q.push(neww);
        &#125;
        E root=q.top();q.pop();
        h[root.t]=0;
        dfs(root.t);
        /*for(int i=1;i&lt;=cur;i++)&#123;
            cout&lt;&lt;e[i].k&lt;&lt;&#39; &#39;&lt;&lt;e[i].l&lt;&lt;&#39; &#39;&lt;&lt;e[i].r&lt;&lt;&#39; &#39;&lt;&lt;e[i].t&lt;&lt;endl;
        &#125;*/
        cout&lt;&lt;ans&lt;&lt;endl;
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>奶牛的聚会</title>
    <url>/2019/06/23/%E5%A5%B6%E7%89%9B%E7%9A%84%E8%81%9A%E4%BC%9A/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>农历新年马上就要到了，奶牛们计划举办一次聚会庆祝新年的到来。但是，奶牛们并不喜欢走太远的路，这会给他们的聚会带来消极情绪，当一头奶牛的消极指数为Wi，他参加聚会所需行走的距离为si，那么他就会给聚会带来Si3*Wi的消极情绪。所有奶牛所在位置都在一条直线上，已知所有奶牛的坐标和消极指数，求如何确定聚会地点，使得所有奶牛给聚会带来的消极情绪之和最小，输出消极情绪之和的最小值。</p>
<p>###输入</p>
<p>第一行包含一个整数 Ca(Ca&lt;=20) ，表示有 Ca 组测试数据。</p>
<p>对于每组测试数据：第一行包含一个整数n(1&lt;=n&lt;=50000) ，表示奶牛的数量。接下来 n 行每行包含两个浮点数Si和wi (-106&lt;=Si&lt;=106, 0&lt;Wi&lt;15)。</p>
<p>###输出</p>
<p>###对于每组测试数据，输出 &quot;Case #c: ans&quot; ，其中c表示测试数据编号，ans表示消极情绪之和的最小值，结果四舍五入为一个整数。</p>
<p>###样例输入 &gt; 1 &gt; 5 &gt; 0.9 2 &gt; 1.4 4 &gt; 3.1 1 &gt; 6.2 1 &gt; 8.3 2</p>
<p>###样例输出 &gt; Case #1: 300</p>
<p>####三分，裸的，可以自己用定义证一下凸函数加凸函数等于凸函数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ll long long
#define ld double
using namespace std;
int T,n;
ld sm1=0,sm2=0,sm3=0,sm4=0;
ld w[50020],s[50020];
ld abs(ld x)&#123;
    return x&gt;0?x:-x;
&#125;
ld pow(ld x,int k)&#123;
    ld cur=1;
    for(int i=1;i&lt;=k;i++)&#123;
        cur*=x;
    &#125;
    return cur;
&#125;
ll ans(ld x)&#123;
    ld cur=x-(ll)x;
    if(cur&lt;0.5) return (ll)x;
    return (ll)x+1;
&#125;
ld smstp(ld ss)&#123;
    ld cur=0;
    for(int i=1;i&lt;=n;i++)&#123;
        cur+=pow(abs(s[i]-ss),3)*w[i];
    &#125;
    return cur;
&#125;
int main()&#123;
    /*ld pla;
     
    for(pla=0.9;pla&lt;=8.3;pla+=0.1)
        cout&lt;&lt;pla&lt;&lt;&quot;:&quot;&lt;&lt;ans(pow(abs(0.9-pla),3)*2+pow(abs(1.4-pla),3)*4+pow(abs(3.1-pla),3)*13+pow(abs(6.2-pla),3)*1+pow(abs(8.3-pla),3)*2)&lt;&lt;endl;
    */
    cin&gt;&gt;T;
    for(int I=1;I&lt;=T;I++)&#123;
        memset(s,0,sizeof(s));
        memset(w,0,sizeof(w));
        scanf(&quot;%d&quot;,&amp;n);
        ld l=1e7,r=-1e7;
        for(int i=1;i&lt;=n;i++)&#123;
            scanf(&quot;%lf%lf&quot;,&amp;s[i],&amp;w[i]);
            //cin&gt;&gt;s[i]&gt;&gt;w[i];
            //cout&lt;&lt;s[i]&lt;&lt;&#39; &#39;&lt;&lt;w[i]&lt;&lt;endl;
            l=min(s[i],l);
            r=max(s[i],r);
        &#125;
        //cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;
        //cout&lt;&lt;r-l&lt;&lt;endl;
        while(r-l&gt;0.00001)&#123;
            ld m1=l+(r-l)/3.0;
            ld m2=r-(r-l)/3.0;
            if(smstp(m1)&lt;smstp(m2))&#123;
                r=m2;
            &#125;
            else&#123;
                l=m1;
            &#125;//cout&lt;&lt;(int)l&lt;&lt;&quot; &quot;&lt;&lt;(int)r&lt;&lt;endl;
        &#125;
        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;I&lt;&lt;&quot;: &quot;&lt;&lt;ans(smstp(l))&lt;&lt;endl;
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>字符串的查找删除</title>
    <url>/2019/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9F%A5%E6%89%BE%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>给定一个短字符串（不含空格），再给定若干字符串，在这些字符串中删除所含有的短字符串。</p>
<p>###输入</p>
<p>输入只有1组数据。 输入一个短字符串（不含空格），再输入若干字符串直到文件结束为止。</p>
<p>###输出</p>
<p>删除输入的短字符串(不区分大小写)并去掉空格,输出。</p>
<p>###样例输入 in #include int main() {</p>
<pre><code>printf(&quot; Hi &quot;);
&#125;</code></pre>
<p>###样例输出 #clude tma() {</p>
<pre><code>prtf(&quot;Hi&quot;);
&#125;</code></pre>
<p>###提示</p>
<p>注:将字符串中的In、IN、iN、in删除。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
string s,ts;
string sub;
void trans(string &amp;xx)&#123;
    for(int i=0;i&lt;xx.size();i++)&#123;
        if(xx[i]&gt;=&#39;A&#39;&amp;&amp;xx[i]&lt;=&#39;Z&#39;) xx[i]+=&#39;a&#39;-&#39;A&#39;;
    &#125;
&#125;
int main()&#123;
     
    cin&gt;&gt;sub;
    trans(sub);
    getchar();
    while(getline(cin,s))&#123;
        ts=s;
        trans(s);
        string::size_type x=s.find(sub);
        while(x!=s.npos)&#123;
            for(int i=x;i&lt;x+sub.size();i++)&#123;
                s[i]=&#39; &#39;;
            &#125;
            x=s.find(sub);
        &#125;
        for(int i=0;i&lt;s.size();i++)&#123;
            if(s[i]!=&#39; &#39;) printf(&quot;%c&quot;,ts[i]);
        &#125;
        cout&lt;&lt;endl;
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>扩展KMP(讲解+模版+例题)</title>
    <url>/2019/08/10/%E6%89%A9%E5%B1%95KMP(%E8%AE%B2%E8%A7%A3+%E6%A8%A1%E7%89%88+%E4%BE%8B%E9%A2%98)/</url>
    <content><![CDATA[<blockquote>
<p>在阅读这篇文章之前，我们假定你已经掌握了<a href="https://www.cnblogs.com/sz-wcc/p/11331357.html">KMP:n+1次探</a>里的定义。 # 引入：扩展KMP是干什么的 扩展KMP解决的是源串S的每一个后缀与模式串P的最长公共前缀的长度的问题，并求解出答案extend数组，例如，ababac与aba的extend数组是3 0 3 0 1 0，这里extend[i]表示s[i:5]（i从0开始）与p[0:2]的最长公共前缀的长度。</p>
</blockquote>
<h1 id="next数组的定义">next数组的定义</h1>
<p>这里的next数组与KMP里的不同。</p>
<p>next[i]表示从i开始的p的后缀与p的最长公共前缀的长度，也就是，p对p求扩展KMP，可以参见<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6629">2019 Multi-University Training Contest 5 - 1006 - string matching</a>。</p>
<p>我们先假设已经有了next数组，来求extend，因为next数组的求法是和extend一样的。</p>
<h1 id="扩展kmp">扩展KMP</h1>
<h3 id="递推已知extendi-1如何求extendi">递推：已知extend[i-1]，如何求extend[i]？</h3>
<p>我们假设在前面匹配时，向右匹配到的最远坐标为last，是从first开始匹配的，也就是说s[first:last]=p[0:last-first]。可以推出s[i:last]=p[i-first:last-first]，但这个不是和p的开头匹配，还不能用，我们取extend[i]=min(last-i+1, next[i-first])，看看p[i-first:last-first]和p开头有多少相同。然后向后检测extend[i]能不能更大，这一块暴力，别忘了最后更新first和last。</p>
<h3 id="初始暴力大法好">初始：暴力大法好</h3>
<p>暴力检测s和p最大公共前缀长度extend[0]。</p>
<h1 id="求next数组">求next数组</h1>
<p>和上面一样。next的0位置必定是p的长度，代码中last初值设为0是为了避免初始化。</p>
<h1 id="例题">例题</h1>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2328">hdu2328</a></p>
<p>给一堆字符串，求最长公共字串。</p>
<p>找一个最短的串，暴力求出每一个后缀，和所有串匹配，找到每个extend里最大的，取总体最小，是一个答案，找到所有答案里长度最长的字典序最小的，就是答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define db double</span><br><span class="line">#define ioss ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">int n,cnt;</span><br><span class="line">ll ext[220],nex[220];</span><br><span class="line">string skr[4020];</span><br><span class="line">string ans[4020];</span><br><span class="line">void getNext(string &amp;strp,ll nextt[])&#123;</span><br><span class="line">    ll pl=strp.size();</span><br><span class="line">    ll fir=0,las=0;</span><br><span class="line">    nextt[0]=pl;</span><br><span class="line">    for(ll i=1;i&lt;pl;i++) &#123;</span><br><span class="line">        nextt[i] = min(las - i + 1, nextt[i - fir]);</span><br><span class="line">        if (nextt[i] &lt; 0) nextt[i] = 0;</span><br><span class="line">        while (i+nextt[i]&lt;pl &amp;&amp; strp[nextt[i]] == strp[i + nextt[i]]) &#123;</span><br><span class="line">            nextt[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i + nextt[i] - 1 &gt; las) &#123;</span><br><span class="line">            las = i + nextt[i] - 1;</span><br><span class="line">            fir = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void exKMP(string &amp;strp,string &amp;strs,ll nextt[],ll extt[])&#123;</span><br><span class="line">    //cout&lt;&lt;&quot;start exKMP:&quot;&lt;&lt;endl;</span><br><span class="line">    getNext(strp,nextt);</span><br><span class="line">    ll pl=strp.size(),sl=strs.size();</span><br><span class="line">    ll fir=0,las=-1,mnl=min(sl,pl);</span><br><span class="line">    //cout&lt;&lt;strp&lt;&lt;endl&lt;&lt;strs&lt;&lt;endl;</span><br><span class="line">    while(las&lt;mnl-1&amp;&amp;strp[las+1]==strs[las+1])&#123;</span><br><span class="line">        las++;</span><br><span class="line">        //cout&lt;&lt;&quot;init++&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    extt[0]=las+1;</span><br><span class="line">    for(ll i=1;i&lt;sl;i++)&#123;</span><br><span class="line">        extt[i]=min(las-i+1,nextt[i-fir]);</span><br><span class="line">        if(extt[i]&lt;0) extt[i]=0;</span><br><span class="line">        while(extt[i]&lt;pl &amp;&amp; i+extt[i]&lt;sl &amp;&amp; strp[extt[i]]==strs[i+extt[i]])&#123;</span><br><span class="line">            extt[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i+extt[i]-1&gt;las)&#123;</span><br><span class="line">            las=i+extt[i]-1;</span><br><span class="line">            fir=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //ioss;</span><br><span class="line">    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)==1&amp;&amp;n)&#123;</span><br><span class="line">        cnt=0;</span><br><span class="line">        int mnlen=300,mnlenx;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">            cin &gt;&gt; skr[i];</span><br><span class="line">            if (skr[i].size() &lt; mnlen) &#123;</span><br><span class="line">                mnlen = skr[i].size();</span><br><span class="line">                mnlenx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;skr[mnlenx].size();i++)&#123;</span><br><span class="line">            ll mn=1e10;</span><br><span class="line">            string cur=skr[mnlenx].substr(i);</span><br><span class="line">            //out&lt;&lt;i+1&lt;&lt;&quot;: cur= &quot;&lt;&lt;cur&lt;&lt;endl;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                ll mx=0;</span><br><span class="line">                exKMP(cur,skr[j],nex,ext);</span><br><span class="line">                /*cout&lt;&lt;&quot;nex: &quot;;</span><br><span class="line">                for(int k=0;k&lt;cur.size();k++)&#123;</span><br><span class="line">                    cout&lt;&lt;nex[k]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;ext: &quot;;*/</span><br><span class="line">                for(int k=0;k&lt;skr[j].size();k++)&#123;</span><br><span class="line">                    //cout&lt;&lt;ext[k]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">                    mx=max(mx,ext[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                //cout&lt;&lt;endl;</span><br><span class="line">                mn=min(mn,mx);</span><br><span class="line">                //cout&lt;&lt;&quot;mn = &quot;&lt;&lt;mn&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if(mn&gt;0)&#123;</span><br><span class="line">                if(cnt==0||(mn==ans[1].size()))&#123;</span><br><span class="line">                    ans[++cnt]=cur.substr(0,mn);</span><br><span class="line">                &#125;</span><br><span class="line">                else if(mn&gt;ans[1].size())&#123;</span><br><span class="line">                    cnt=0;</span><br><span class="line">                    ans[++cnt]=cur.substr(0,mn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt)&#123;</span><br><span class="line">            sort(ans+1,ans+1+cnt);</span><br><span class="line">            cout&lt;&lt;ans[1]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else cout&lt;&lt;&quot;IDENTITY LOST&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>数学技巧（位运算）</title>
    <url>/2019/08/04/%E6%95%B0%E5%AD%A6%E6%8A%80%E5%B7%A7%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%89/</url>
    <content><![CDATA[<p>1、n mod 2^k = n&amp;((1&lt;&lt;k)-1) 2、判断n是否为2的正整数幂n&gt;1 &amp;&amp; !(n&amp;(n-1))</p>
]]></content>
  </entry>
  <entry>
    <title>最小的交换</title>
    <url>/2019/02/22/%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<p>一、归并排序</p>
<p>递归思路，将一个序列二分，使前半段有序，使后半段有序，然后使用双指针扫一遍使整段有序。</p>
<p>对于n个元素，每个元素都在排序1个元素，2个元素，4个元素，8个元素......的时候出现，因此复杂度是O(nlogn)。</p>
<p>二、求逆序数</p>
<p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。</p>
<p>如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。给出一个整数序列，求该序列的逆序数。</p>
<h1 id="输入">输入</h1>
<pre><code>第1行：N，N为序列的长度（n &lt;= 50000)
第2 - N + 1行：序列中的元素（0 &lt;= A[i] &lt;= 10^9）</code></pre>
<h1 id="输出">输出</h1>
<pre><code>输出逆序数</code></pre>
<h1 id="输入样例">输入样例</h1>
<pre><code>4
2
4
3
1</code></pre>
<h1 id="输出样例">输出样例</h1>
<h1 id="section">4</h1>
<h1 id="思路">思路</h1>
<pre><code>____考虑在每次归并两个有序序列的过程中，我们会将后面一个有序序列的部分元素前移，那么从后向前中间 **超越的元素** 与它成为一个逆序对，代码中为当前总位置j减去已经被分配的比它小的元素k，即 **超越的元素** 数。 _ _  
__</code></pre>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 int a[50020],b[50020];
 5 int n;
 6 long long merge(int low,int mid,int high)&#123;
 7     int i=low,j=mid+1,k=low;
 8     long long count=0;
 9     while(i&lt;=mid&amp;&amp;j&lt;=high)&#123;
10         if(a[i]&lt;=a[j])&#123;
11             b[k++]=a[i++];
12         &#125;
13         else&#123;
14             b[k++]=a[j++];
15             count+=j-k;
16         &#125;
17     &#125;
18     while(i&lt;=mid)&#123;
19         b[k++]=a[i++];
20     &#125;
21     while(j&lt;=high)&#123;
22         b[k++]=a[j++];
23     &#125;
24     for(i=low;i&lt;=high;i++)&#123;
25         a[i]=b[i];
26     &#125;
27     return count;
28 &#125;
29 long long mergeSort(int x,int y)&#123;
30     
31     if(x&lt;y)&#123;
32         int mid=(x+y)/2;
33         long long count=0;
34         count+=mergeSort(x,mid);
35         count+=mergeSort(mid+1,y);
36         count+=merge(x,mid,y);
37         return count;
38     &#125;
39     return 0;
40 &#125;
41 int main()&#123;
42     cin&gt;&gt;n;
43     for(int i=0;i&lt;n;i++)&#123;
44         scanf(&quot;%d&quot;,&amp;a[i]);
45     &#125;
46     cout&lt;&lt;mergeSort(0,n-1);
47     return 0;
48 &#125;</code></pre>
<p>View Code</p>
<p>三、最小的交换</p>
<p>只能相邻元素交换，求让序列升序的最小交换次数。</p>
<p>我们不可避免的让大数向后交换，那么我们考虑最大的一个数，让其向后交换，肯定会交换到最后一位，交换的次数为后面比它小的数的个数，即包含它且它更大的逆序对数，再把次小的元素向后移动......最后的移动次数即为逆序对数。</p>
<p>代码同上</p>
]]></content>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2019/04/01/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="收拾行装再次出发----201941总结"><a href="https://www.cnblogs.com/sz-wcc/p/10638564.html">#0 收拾行装，再次出发----2019/4/1总结</a></h1>
<h1 id="论目标----201947总结"><a href="https://www.cnblogs.com/sz-wcc/p/10663373.html">#1 论目标----2019/4/7总结</a></h1>
<h1 id="contest----2019414总结"><a href="https://www.cnblogs.com/sz-%20wcc/p/10707204.html">#2 contest++----2019/4/14总结</a></h1>
<h1 id="南昌邀请赛网络赛----2019421总结"><a href="https://www.cnblogs.com/sz-wcc/p/10745366.html">#3 南昌邀请赛网络赛----2019/4/21总结</a></h1>
<h1 id="最近三场比赛总结及展望----201963总结"><a href="https://www.cnblogs.com/sz-%20wcc/p/10970930.html">#4 最近三场比赛总结及展望----2019/6/3总结</a></h1>
<p>模板</p>
<p>一、队伍训练情况</p>
<p>二、个人训练情况</p>
<p>三、遇到的问题&amp;可行的解决方案</p>
]]></content>
  </entry>
  <entry>
    <title>欧几里得游戏(博弈论启蒙)</title>
    <url>/2019/06/23/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%B8%B8%E6%88%8F(%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%90%AF%E8%92%99)/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>小明和小红在玩欧几里得游戏。他们从两个自然数开始，第一个玩家小明，从两个数的较大数中减去较小数的尽可能大的正整数倍，只要差为非负即可。然后，第二个玩家小红，对得到的两个数进行同样的操作，然后又是小明。就这样轮流进行游戏，直至某个玩家将较大数减去较小数的某个倍数之后差为0为止，此时游戏结束，该玩家就是胜利者。</p>
<p>###输入</p>
<p>输入包含多组测试数据。每组输入两个正整数，表示游戏一开始的两个数，游戏总是小明先开始。 当输入两个0的时候，输入结束。</p>
<p>###输出</p>
<p>对于每组输入，输出最后的胜者，我们认为他们两个都是顶尖高手，每一步游戏都做出了最佳的选择。 具体输出格式见输出样例。</p>
<p>###样例输入 &gt; 34 12 &gt; 15 24 &gt; 0 0</p>
<p>###样例输出 &gt; xiaoming wins &gt; xiaohong wins</p>
<p>####两句话，能转移到必败点的是必胜点，只能转移到必胜点的是必败点。</p>
<p><img src="https://img2018.cnblogs.com/blog/1575943/201906/1575943-20190623095542588-1832008552.png" /></p>
<p>我是这么推出来的，或者从定理出发，一个点不是必败点就是必胜点，对三角形右下角分别假设，都可以推出m/n&gt;2必胜</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
int n,m;
int main()&#123;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2&amp;&amp;n&amp;&amp;m)&#123;
        if(n&gt;m) swap(n,m);
        bool flag=true;
        while(m%n!=0&amp;&amp;m/n==1)&#123;
            m-=n;
            if(n&gt;m) swap(n,m);
            flag=!flag;
        &#125;
        if(flag)&#123;
            printf(&quot;xiaoming wins\n&quot;);
        &#125;
        else printf(&quot;xiaohong wins\n&quot;);
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>欧拉函数</title>
    <url>/2019/09/06/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="定义">定义</h2>
<p>n的欧拉函数表示小于n的数中和n互质的数。</p>
<h2 id="求法">求法</h2>
<p>定义n为正整数，ti为n唯一分解的质数基。</p>
<p>利用n的欧拉函数为n*所有的(ti-1)/ti来求。</p>
<p>第一种方法为sqrt(n)的时间单个求。</p>
<p>第二种方法利用质数筛，如果循环到一个数，其数组没被变过，说明这个数是质数，可以往后修改其他数。</p>
<h2 id="模版">模版</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">#define mem(a, x) memset(a,x,sizeof(a))</span><br><span class="line">#define io_opt ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">typedef std::pair&lt;int, int&gt; Pii;</span><br><span class="line">typedef std::pair&lt;ll, ll&gt; Pll;</span><br><span class="line">ll power(ll a, ll b,ll p) &#123; ll res = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; &#125; return res; &#125;</span><br><span class="line">ll gcd(ll p, ll q) &#123; return q == 0 ? p : gcd(q, p % q); &#125;</span><br><span class="line">ll _abs(ll x)&#123;return x &lt; 0 ? -x : x;&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">#define inf 0x7fffffffffffffff</span><br><span class="line">using namespace std;</span><br><span class="line">int euler_phi(int n)&#123;</span><br><span class="line">    int res=n;</span><br><span class="line">    for(int i=2;i*i&lt;=n;i++)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            res=res/i*(i-1);</span><br><span class="line">            for(;n%i==0;n/=i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n!=1) res=res/n*(n-1);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">const int MAX_N=3000000;</span><br><span class="line">int euler[MAX_N+20];</span><br><span class="line">void euler_phi2()&#123;</span><br><span class="line">    for(int i=0;i&lt;=MAX_N;i++) euler[i]=i;</span><br><span class="line">    for(int i=2;i&lt;=MAX_N;i++)&#123;</span><br><span class="line">        if(euler[i]==i)&#123;</span><br><span class="line">            for(int j=i;j&lt;=MAX_N;j+=i)&#123;</span><br><span class="line">                euler[j]=euler[j]/i*(i-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    io_opt;</span><br><span class="line">    euler_phi2();</span><br><span class="line">    int a,b;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class="line">        ll sum=0;</span><br><span class="line">        for(int i=a;i&lt;=b;i++)&#123;</span><br><span class="line">            sum+=euler[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>（更新）西南民族大学第十届校赛（同步赛）</title>
    <url>/2018/12/30/%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89%E8%A5%BF%E5%8D%97%E6%B0%91%E6%97%8F%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%B1%8A%E6%A0%A1%E8%B5%9B%EF%BC%88%E5%90%8C%E6%AD%A5%E8%B5%9B%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/322#question">西南民族大学第十届校赛（同步赛）</a></p>
<p>打了11道，果然AK是这辈子也不可能的么QAQ</p>
<p>A <a href="https://ac.nowcoder.com/acm/contest/322/A">dreamstart的催促</a></p>
<p>快速幂。。。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 #define MOD 10000019
 5 #define ll long long
 6 ll n,a;
 7 ll ANS=0;
 8 ll speed(ll a,ll b)&#123;
 9     ll ans=1,cur=a%MOD;
10     while(b)&#123;
11         if(b&amp;1)&#123;
12             ans*=cur;
13             ans%=MOD;
14         &#125;
15         cur*=cur;
16         cur%=MOD;
17         b&gt;&gt;=1;
18     &#125;
19     return ans%MOD;
20 &#125;
21 int main()&#123;
22     cin&gt;&gt;n;
23     for(int i=1;i&lt;=n;i++)&#123;
24         scanf(&quot;%lld&quot;,&amp;a);
25         ANS+=speed(a,i);
26         ANS%=MOD;
27     &#125;
28     printf(&quot;%lld\n&quot;,ANS);
29      
30     return 0;
31 &#125;</code></pre>
<p>A</p>
<p>B <a href="https://ac.nowcoder.com/acm/contest/322/B">TRDD got lost again</a></p>
<p>很麻烦的一道题，我的做法是先把图转成n*m的，然后用二进制记录是否可以通过，再dfs。一开始cin.getline()超时，后来用的gets()。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;cstring&gt;
 4 #include&lt;queue&gt;
 5 #include&lt;string&gt;
 6 using namespace std;
 7 #define MOD 10000019
 8 #define ll long long
 9 #define MAXN 1000020
10 int a[3004][3004],n,m;
11 char s1[6020],s2[6020],s3[6020];
12 bool k[3004][3004];
13 int f[6][6]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;//上，下，右，左
14 int sx,sy,ex,ey;
15 struct Point&#123;
16     int x,y,step;
17 &#125;;
18 int bfs()&#123;
19     memset(k,true,sizeof(k));
20     queue&lt;Point&gt;q;
21     q.push((Point)&#123;sx,sy,1&#125;);
22     k[sx][sy]=false;
23     while(!q.empty())&#123;
24         Point cur=q.front();q.pop();
25         if(cur.x==ex&amp;&amp;cur.y==ey) return cur.step;
26         for(int i=0;i&lt;4;i++)&#123;
27             int x=cur.x+f[i][0],y=cur.y+f[i][1];
28             if((a[cur.x][cur.y]&amp;(1&lt;&lt;i))&amp;&amp;k[x][y]&amp;&amp;x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m)&#123;
29                 q.push((Point)&#123;x,y,cur.step+1&#125;);
30                 k[x][y]=false;
31             &#125;
32         &#125;
33     &#125;
34     return 0;
35 &#125;
36 int main()&#123;
37     scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
38     getchar();
39     gets(s1);
40     //cout&lt;&lt;s1&lt;&lt;endl;
41     for(int i=1;i&lt;=n;i++)&#123;
42         gets(s2);
43         gets(s3);
44         for(int j=1;j&lt;=2*m;j+=2)&#123;
45             if(s2[j]==&#39;S&#39;)&#123;
46                 sx=i;
47                 sy=(j+1)/2;
48             &#125;
49             if(s2[j]==&#39;T&#39;)&#123;
50                 ex=i;
51                 ey=(j+1)/2;
52             &#125;
53             int temp=0;
54             if(s1[j]==&#39; &#39;) temp|=1;
55             if(s3[j]==&#39; &#39;) temp|=2;
56             if(s2[j+1]==&#39; &#39;) temp|=4;
57             if(s2[j-1]==&#39; &#39;) temp|=8;
58             a[i][(j+1)/2]=temp;
59         &#125;
60         strcpy(s1,s3);
61     &#125;
62     /*for(int i=1;i&lt;=n;i++)&#123;
63         for(int j=1;j&lt;=m;j++)&#123;
64             printf(&quot;%d &quot;,a[i][j]);
65         &#125;
66         cout&lt;&lt;endl;
67     &#125;*/
68     int ans=bfs();
69     if(!ans)&#123;
70         printf(&quot;TRDD Got lost...TAT\n&quot;);
71     &#125;
72     else&#123;
73         printf(&quot;%d\n&quot;,ans);
74     &#125;
75     return 0;
76 &#125;</code></pre>
<p>B</p>
<p>C <a href="https://ac.nowcoder.com/acm/contest/322/C">Company</a></p>
<p>递归，返回下面的值并记录，一开始以为先求深度，后来发现不用。。。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 #define MOD 10000019
 5 #define ll long long
 6 #define MAXN 200020*2
 7 int n,k;
 8 int pe[MAXN];
 9 struct Edge&#123;
10     int u,v,next;
11 &#125;e[MAXN];
12 int g[MAXN];
13 int dep[MAXN],f[MAXN],kk[MAXN];
14 int dfs(int cur,int d)&#123;
15     dep[cur]=d;
16     f[cur]=1;
17     int ans=0;
18     for(int i=g[cur];i&gt;0;i=e[i].next)&#123;
19         int v=e[i].v;
20         if(!f[v])&#123;
21             ans+=dfs(v,d+1);
22         &#125;
23     &#125;
24     if(pe[cur]&lt;=k) return kk[cur]=ans+1;
25     return kk[cur]=ans;
26 &#125;
27 int main()&#123;
28     scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
29     for(int i=1;i&lt;=n;i++)&#123;
30         scanf(&quot;%d&quot;,&amp;pe[i]);
31     &#125;
32     int xx,yy;
33     for(int i=1;i&lt;=n-1;i++)&#123;
34         scanf(&quot;%d%d&quot;,&amp;xx,&amp;yy);
35         e[i]=(Edge)&#123;xx,yy,g[xx]&#125;;g[xx]=i;
36         e[i+n-1]=(Edge)&#123;yy,xx,g[yy]&#125;;g[yy]=i+n-1;
37     &#125;
38     dfs(1,1);
39     for(int i=1;i&lt;=n;i++)&#123;
40         printf(&quot;%d &quot;,kk[i]);
41     &#125;
42      
43     return 0;
44 &#125;</code></pre>
<p>C</p>
<p>D <a href="https://ac.nowcoder.com/acm/contest/322/D">&gt;A-&gt;B-&gt;C-</a></p>
<p>从任意一个点能搜3个回来就可以。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 #define MOD 10000019
 5 #define ll long long
 6 #define MAXN 1000020
 7 int n,a[5020],f[5020],k=0;
 8 void dfs(int rig,int x,int d)&#123;
 9     if(d==4)&#123;
10         if(rig==x)&#123;
11             k=1;
12         &#125;
13         return;
14     &#125;
15     dfs(rig,a[x],d+1);
16 &#125;
17 int main()&#123;
18     cin&gt;&gt;n;
19     for(int i=1;i&lt;=n;i++)&#123;
20         scanf(&quot;%d&quot;,&amp;a[i]);
21     &#125;
22     for(int i=1;i&lt;=n;i++)&#123;
23         dfs(i,i,1);
24         if(k==1) break;
25     &#125;
26     if(k==1) printf(&quot;YES\n&quot;);
27     else&#123;
28         printf(&quot;NO\n&quot;);
29     &#125;
30     return 0;
31 &#125;</code></pre>
<p>D</p>
<p>E <a href="https://ac.nowcoder.com/acm/contest/322/E">PPY的字符串</a></p>
<p>模拟，数组要开大一点。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;cstring&gt;
 4 using namespace std;
 5 #define MOD 10000019
 6 #define ll long long
 7 #define MAXN 1000020
 8 int a[500000],b[500000],l=0;
 9 int n,aa;
10 void fun()&#123;
11     int nl=0,cur=a[1],cnt=0;
12     for(int i=1;i&lt;=l;i++)&#123;
13         if(a[i]==cur)&#123;
14             cnt++;
15         &#125;
16         if((a[i+1]!=cur&amp;&amp;i&lt;l)||i==l)&#123;
17             b[++nl]=cnt;
18             b[++nl]=cur;
19             cnt=0;
20             cur=a[i+1];
21         &#125;
22     &#125;
23      
24     l=nl;
25 &#125;
26 int main()&#123;
27     cin&gt;&gt;aa&gt;&gt;n;
28      
29     for(int i=1;aa;i++)&#123;
30         a[i]=aa%10;
31         aa/=10    ;
32         l++;
33     &#125;
34     for(int i=1;i&lt;=l/2;i++)&#123;
35         swap(a[i],a[l-i+1]);
36     &#125;
37     /*for(int i=1;i&lt;=l;i++)&#123;
38         printf(&quot;%d&quot;,a[i]);
39     &#125;*/
40     for(int i=1;i&lt;=n-1;i++)&#123;
41         memset(b,0,sizeof(b));
42         fun();
43         for(int j=1;j&lt;=l;j++)&#123;
44             a[j]=b[j];
45         &#125;
46     &#125;
47     cout&lt;&lt;l&lt;&lt;&#39; &#39;;
48     for(int i=1;i&lt;=l;i++)&#123;
49         printf(&quot;%d&quot;,a[i]);
50     &#125;
51     cout&lt;&lt;endl;
52     return 0;
53 &#125;</code></pre>
<p>E</p>
<p>F <a href="https://ac.nowcoder.com/acm/contest/322/F">集训队脱单大法：这是一道只能由学姐我自己出数据的水题</a></p>
<p>左边找最大值，右边找最大值。</p>
<p>即使分成两半也让单身狗羡慕至极呢</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 #define MOD 10000019
 5 #define ll long long
 6 #define MAXN 1000020
 7 int n,ans;
 8 int a[MAXN];
 9 int lm[MAXN],rm[MAXN];
10 int abss(int a)&#123;
11     return a&gt;0?a:-a;
12 &#125;
13 int main()&#123;
14     cin&gt;&gt;n;
15     for(int i=1;i&lt;=n;i++)&#123;
16         scanf(&quot;%d&quot;,&amp;a[i]);
17     &#125;
18     for(int i=1;i&lt;=n-1;i++)&#123;
19         lm[i]=max(lm[i-1],a[i]);
20     &#125;
21     for(int i=n-1;i&gt;=1;i--)&#123;
22         rm[i]=max(a[i+1],rm[i+1]);
23     &#125;
24     for(int i=1;i&lt;=n-1;i++)&#123;
25         ans=max(ans,abss(lm[i]-rm[i]));
26     &#125;
27     cout&lt;&lt;ans&lt;&lt;endl;
28     return 0;
29 &#125;</code></pre>
<p>F</p>
<p>G <a href="https://ac.nowcoder.com/acm/contest/322/G">不想再WA了</a></p>
<p>DFS赋值写一遍，然后愉快地打表咯。。。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 #define MOD 10000019
 5 #define ll long long
 6 #define MAXN 1000020
 7 int ANS[20]=&#123;0,3,8,21,55,144,377,987,2584,6765,17711&#125;;
 8 int T,n;
 9 int main()&#123;
10     cin&gt;&gt;T;
11     while(T--)&#123;
12         cin&gt;&gt;n;
13         printf(&quot;%d\n&quot;,ANS[n]);
14     &#125;
15     return 0;
16 &#125;</code></pre>
<p>G</p>
<p>H <a href="https://ac.nowcoder.com/acm/contest/322/H">Ricky's RealDan's Ricky</a></p>
<p>更新，RealDan拥有把偶数变成奇数的神奇能力，所以只要Ricky一次不能赢，就输了。</p>
<p>当只有一堆且为偶数是为Ricky胜</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 int T,n;
 5 int a[100020];
 6 int main()&#123;
 7     cin&gt;&gt;T;
 8     while(T--)&#123;
 9         scanf(&quot;%d&quot;,&amp;n);
10         for(int i=1;i&lt;=n;i++)&#123;
11             scanf(&quot;%d&quot;,&amp;a[i]); 
12         &#125; 
13         if(n==1&amp;&amp;a[1]%2==0)&#123;
14             cout&lt;&lt;&quot;Ricky is Winner&quot;&lt;&lt;endl;
15         &#125;
16         else&#123;
17             cout&lt;&lt;&quot;RealDan is Winner&quot;&lt;&lt;endl;
18         &#125;
19     &#125;
20     return 0;
21 &#125;</code></pre>
<p>H</p>
<p>I <a href="https://ac.nowcoder.com/acm/contest/322/I">小A的期末作业</a></p>
<p>C++语言入门题。。。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 #define MOD 10000019
 5 #define ll long long
 6 #define MAXN 1000020
 7 int n;
 8 int main()&#123;
 9     cin&gt;&gt;n;
10     for(int i=1;i&lt;=n-1;i++)&#123;
11         for(int j=1;j&lt;=i-1;j++)&#123;
12             printf(&quot; &quot;);
13         &#125;
14         for(int j=1;j&lt;=n;j++)&#123;
15             printf(&quot;*&quot;);
16         &#125;
17         cout&lt;&lt;endl;
18     &#125;
19     for(int i=1;i&lt;=n-1;i++)&#123;
20         printf(&quot; &quot;);
21     &#125;
22     for(int i=1;i&lt;=n;i++)&#123;
23         printf(&quot;*&quot;);
24     &#125;
25     cout&lt;&lt;endl;
26     for(int i=n-1;i&gt;=1;i--)&#123;
27         for(int j=1;j&lt;=i-1;j++)&#123;
28             printf(&quot; &quot;);
29         &#125;
30         for(int j=1;j&lt;=n;j++)&#123;
31             printf(&quot;*&quot;);
32         &#125;
33         cout&lt;&lt;endl;
34     &#125;
35     return 0;
36 &#125;</code></pre>
<p>I</p>
<p>J <a href="https://ac.nowcoder.com/acm/contest/322/J">怪盗基德 &amp; 月之瞳宝石</a></p>
<p>二分，这是伟大玄学的胜利。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;cstring&gt;
 4 #include&lt;queue&gt;
 5 #include&lt;string&gt;
 6 #include&lt;algorithm&gt;
 7 using namespace std;
 8 #define MOD 10000019
 9 #define ll long long
10 #define MAXN 1000020
11 int n,m;
12 int a[100020],b[100020];
13 bool fun(ll s)&#123;
14     int cur=1;
15     ll xl=b[1]-s,xr=b[1]+s;
16     for(int i=1;i&lt;=n;i++)&#123;
17         if(a[i]&lt;xl)&#123;
18             return false;
19         &#125;
20         if(a[i]&gt;xr)&#123;
21             while(a[i]&gt;xr||a[i]&lt;xl)&#123;
22                 cur++;
23                 xl=b[cur]-s;
24                 xr=b[cur]+s;
25                 if(cur&gt;m)&#123;
26                     return false;
27                 &#125;
28             &#125;
29         &#125;
30     &#125;
31     return true;
32 &#125;
33 int main()&#123;
34     cin&gt;&gt;n&gt;&gt;m;
35     for(int i=1;i&lt;=n;i++)&#123;
36         scanf(&quot;%d&quot;,&amp;a[i]);
37     &#125;
38     for(int j=1;j&lt;=m;j++)&#123;
39         scanf(&quot;%d&quot;,&amp;b[j]);
40     &#125;
41     sort(a+1,a+1+n);
42     sort(b+1,b+1+m);
43     ll l=0,r=4e9+1;
44     while(l&lt;r)&#123;
45         ll mid=(l+r)/2;
46         if(fun(mid))&#123;
47             r=mid;
48         &#125;
49         else&#123;
50             l=mid+1;
51         &#125;
52     &#125;
53     printf(&quot;%lld\n&quot;,l);
54 //  printf(&quot;%d&quot;,fun(4));
55     return 0;
56 &#125;</code></pre>
<p>J</p>
<p>K <a href="https://ac.nowcoder.com/acm/contest/322/K">正方体</a></p>
<p>第一遍不知道为什么WA，修改了一下1，3行赋值就对了，图形限定这么严格也是入门题了</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;cstring&gt;
 4 using namespace std;
 5 #define MOD 10000019
 6 #define ll long long
 7 #define MAXN 1000020
 8 ll a[10][10];
 9 int T;
10 int main()&#123;
11     cin&gt;&gt;T;
12     for(int i=1;i&lt;=T;i++)&#123;
13         memset(a,0,sizeof(a));
14         ll x=0,y=0;
15         for(int j=1;j&lt;=3;j++)&#123;
16             for(int k=1;k&lt;=4;k++)&#123;
17                 scanf(&quot;%lld&quot;,&amp;a[j][k]);
18                 if(j==1&amp;&amp;a[j][k])&#123;
19                     x=a[j][k];
20                 &#125;
21                 if(j==3&amp;&amp;a[j][k])&#123;
22                     y=a[j][k];
23                 &#125;
24             &#125;
25         &#125;
26         if(x==y&amp;&amp;a[2][1]==a[2][3]&amp;&amp;a[2][2]==a[2][4])&#123;
27             printf(&quot;Yes!\n&quot;);
28         &#125;
29         else&#123;
30             printf(&quot;No!\n&quot;);
31         &#125;
32         if(i%50==0)cout&lt;&lt;endl;
33     &#125;
34     return 0;
35 &#125;</code></pre>
<p>K</p>
<p>L <a href="https://ac.nowcoder.com/acm/contest/322/L">简单的分数</a></p>
<p>直接想到了GCD，也算是个模拟吧。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 #define MOD 10000019
 5 #define ll long long
 6 #define MAXN 1000020
 7 int T,op,a,b,c,d,e,f;
 8 int gcd(int a,int b)&#123;
 9     return b==0?a:gcd(b,a%b);
10 &#125;
11 int main()&#123;
12     cin&gt;&gt;T;
13     while(T--)&#123;
14         cin&gt;&gt;op&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
15         if(op==1)&#123;
16             e=a*d+b*c;
17             f=b*d;
18             int k=gcd(e,f);
19             e/=k;
20             f/=k;
21             cout&lt;&lt;e&lt;&lt;&#39;/&#39;&lt;&lt;f&lt;&lt;endl;
22         &#125;
23         else&#123;
24             e=a*d-b*c;
25             f=b*d;
26             int kkkkk=0;
27             if(e&lt;0)&#123;
28                 e=-e;
29                 kkkkk=1;
30             &#125;
31             int k=gcd(e,f);
32             e/=k;
33             f/=k;
34             if(kkkkk==0) cout&lt;&lt;e&lt;&lt;&#39;/&#39;&lt;&lt;f&lt;&lt;endl;
35             else&#123;
36                 cout&lt;&lt;&#39;-&#39;&lt;&lt;e&lt;&lt;&#39;/&#39;&lt;&lt;f&lt;&lt;endl;
37             &#125;
38         &#125;
39     &#125;
40     return 0;
41 &#125;</code></pre>
<p>L</p>
<p>M <a href="https://ac.nowcoder.com/acm/contest/322/M">HJ浇花</a></p>
<p>/*带的树状数组板子发现是坏的-&gt;_-&gt;</p>
<p>然后从左到右算改了N发还是不对。。。*/</p>
<p>emmmm没有啥树状数组，从左到右扫一遍看成爬山，用一个数组cnt[i]来统计在i位置向上还是向下，对于每组l，r，cnt[l]++，cnt[r+1]--，从0扫到max(r)+1，对于每个cnt[i]不为0的i，用i和上一个cnt不为0的位置和当前层数更新ans数组，然后更新当前层数。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /></p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 using namespace std;
 4 int n,cnt[1000020],last,now,rmx,ans[1000020]; 
 5 int main()&#123;
 6     cin&gt;&gt;n;
 7     int l,r;
 8     for(int i=1;i&lt;=n;i++)&#123;
 9         scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
10         rmx=max(rmx,r);
11         cnt[l]++;
12         cnt[r+1]--;
13     &#125;
14     for(int i=0;i&lt;=rmx+1;i++)&#123;
15         if(cnt[i]!=0)&#123;
16             ans[now]+=(i-last);
17             last=i;
18             now+=cnt[i];
19         &#125;
20     &#125; 
21     cout&lt;&lt;ans[1];
22     for(int i=2;i&lt;=n;i++)&#123;
23         printf(&quot; %d&quot;,ans[i]);
24     &#125;
25     return 0;
26 &#125;</code></pre>
<p>M</p>
]]></content>
  </entry>
</search>
